<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Context Harness ‚Äî Interactive Demo</title>
<style>
  :root {
    --bg: #0a0e17;
    --surface: #111827;
    --surface-2: #1a2332;
    --surface-3: #0f1a2a;
    --border: #1e2d3d;
    --text: #e2e8f0;
    --text-dim: #8892a4;
    --accent: #3b82f6;
    --accent-glow: rgba(59, 130, 246, 0.15);
    --green: #22c55e;
    --yellow: #eab308;
    --red: #ef4444;
    --orange: #f97316;
    --purple: #a855f7;
    --teal: #14b8a6;
    --radius: 12px;
    --mono: 'SF Mono', 'Fira Code', 'JetBrains Mono', monospace;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    line-height: 1.6;
  }

  /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
  header {
    border-bottom: 1px solid var(--border);
    padding: 14px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: var(--surface);
    position: sticky;
    top: 0;
    z-index: 100;
  }

  .logo {
    display: flex;
    align-items: center;
    gap: 12px;
    font-weight: 700;
    font-size: 18px;
  }

  .logo-icon {
    width: 32px;
    height: 32px;
    background: linear-gradient(135deg, var(--accent), var(--purple));
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
  }

  .header-right {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .nav-tabs {
    display: flex;
    gap: 4px;
    background: var(--surface-2);
    border-radius: 8px;
    padding: 3px;
  }

  .nav-tab {
    padding: 6px 16px;
    border-radius: 6px;
    border: none;
    background: transparent;
    color: var(--text-dim);
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
    font-weight: 500;
  }

  .nav-tab:hover { color: var(--text); }

  .nav-tab.active {
    background: var(--accent);
    color: white;
  }

  .status-pill {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px 12px;
    border-radius: 20px;
    background: var(--surface-2);
    border: 1px solid var(--border);
  }

  .status-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background: var(--red);
    animation: pulse 2s infinite;
  }

  .status-dot.connected { background: var(--green); }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  .status-label {
    font-size: 12px;
    color: var(--text-dim);
    font-family: var(--mono);
  }

  /* ‚îÄ‚îÄ Pages ‚îÄ‚îÄ */
  .page { display: none; }
  .page.active { display: block; }

  .container {
    max-width: 1100px;
    margin: 0 auto;
    padding: 32px 24px;
  }

  /* ‚îÄ‚îÄ Info Tips ‚îÄ‚îÄ */
  .info-tip {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--surface-2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    font-size: 11px;
    cursor: help;
    position: relative;
    vertical-align: middle;
    margin-left: 4px;
    flex-shrink: 0;
  }

  .info-tip:hover { border-color: var(--accent); color: var(--accent); }

  .info-tip .tip-text {
    display: none;
    position: absolute;
    bottom: calc(100% + 8px);
    left: 50%;
    transform: translateX(-50%);
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px 16px;
    font-size: 13px;
    color: var(--text);
    width: 300px;
    line-height: 1.5;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    z-index: 200;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    font-weight: 400;
    text-align: left;
    cursor: default;
  }

  .info-tip:hover .tip-text { display: block; }

  .tip-text::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: var(--border);
  }

  /* ‚îÄ‚îÄ Learn Banner ‚îÄ‚îÄ */
  .learn-banner {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 16px 20px;
    margin-bottom: 24px;
    display: flex;
    align-items: flex-start;
    gap: 12px;
    font-size: 14px;
    color: var(--text-dim);
    line-height: 1.6;
  }

  .learn-banner .banner-icon {
    font-size: 20px;
    flex-shrink: 0;
    margin-top: 1px;
  }

  .learn-banner strong { color: var(--text); }

  .learn-banner code {
    background: var(--surface-2);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: var(--mono);
    font-size: 12px;
    color: var(--accent);
  }

  /* ‚îÄ‚îÄ Search Section ‚îÄ‚îÄ */
  .search-section { margin-bottom: 24px; }

  .section-label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-dim);
    margin-bottom: 10px;
    font-weight: 600;
  }

  .search-box {
    display: flex;
    gap: 0;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    overflow: hidden;
    transition: border-color 0.2s;
  }

  .search-box:focus-within {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px var(--accent-glow);
  }

  .search-input {
    flex: 1;
    padding: 14px 20px;
    background: transparent;
    border: none;
    color: var(--text);
    font-size: 16px;
    outline: none;
    font-family: inherit;
  }

  .search-input::placeholder { color: var(--text-dim); }

  .search-btn {
    padding: 14px 24px;
    background: var(--accent);
    color: white;
    border: none;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
    white-space: nowrap;
  }

  .search-btn:hover { background: #2563eb; }

  /* ‚îÄ‚îÄ Mode Selector ‚îÄ‚îÄ */
  .mode-section {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-top: 14px;
    flex-wrap: wrap;
  }

  .mode-btn {
    padding: 8px 18px;
    border-radius: 20px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text-dim);
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
    font-family: var(--mono);
  }

  .mode-btn:hover { border-color: var(--accent); color: var(--text); }

  .mode-btn.active {
    background: var(--accent-glow);
    border-color: var(--accent);
    color: var(--accent);
  }

  .mode-btn.disabled {
    opacity: 0.35;
    cursor: not-allowed;
  }

  .mode-btn.disabled:hover {
    border-color: var(--border);
    color: var(--text-dim);
  }

  .source-filter {
    padding: 8px 14px;
    border-radius: 20px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text-dim);
    font-size: 13px;
    font-family: var(--mono);
    outline: none;
    cursor: pointer;
  }

  .source-filter:focus { border-color: var(--accent); }

  /* ‚îÄ‚îÄ Mode Explainer ‚îÄ‚îÄ */
  .mode-explainer {
    margin-top: 14px;
    padding: 14px 18px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-left: 3px solid var(--accent);
    border-radius: 0 var(--radius) var(--radius) 0;
    font-size: 13px;
    color: var(--text-dim);
    line-height: 1.6;
  }

  .mode-explainer strong { color: var(--text); }
  .mode-explainer code {
    background: var(--surface-2);
    padding: 1px 5px;
    border-radius: 3px;
    font-family: var(--mono);
    font-size: 12px;
    color: var(--accent);
  }

  .embed-hint {
    display: none;
    margin-top: 12px;
    padding: 10px 16px;
    background: rgba(234, 179, 8, 0.08);
    border: 1px solid rgba(234, 179, 8, 0.2);
    border-radius: 8px;
    font-size: 13px;
    color: var(--yellow);
    font-family: var(--mono);
    text-align: center;
  }

  .embed-hint.visible { display: block; }

  @keyframes flash {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; transform: scale(1.01); }
  }

  /* ‚îÄ‚îÄ Stats ‚îÄ‚îÄ */
  .stats-bar {
    display: none;
    gap: 20px;
    margin-top: 14px;
    padding: 10px 16px;
    background: var(--surface);
    border-radius: var(--radius);
    border: 1px solid var(--border);
    font-size: 12px;
    flex-wrap: wrap;
  }

  .stats-bar.visible { display: flex; }

  .stat {
    display: flex;
    align-items: center;
    gap: 5px;
    color: var(--text-dim);
    font-family: var(--mono);
  }

  .stat-value { color: var(--accent); font-weight: 600; }

  /* ‚îÄ‚îÄ Suggestions ‚îÄ‚îÄ */
  .suggestions {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 8px;
    margin-top: 20px;
  }

  .suggestion {
    padding: 8px 16px;
    border-radius: 20px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text-dim);
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .suggestion:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: var(--accent-glow);
  }

  /* ‚îÄ‚îÄ Results ‚îÄ‚îÄ */
  .results-area { margin-top: 24px; }

  .empty-state {
    text-align: center;
    padding: 48px 24px;
    color: var(--text-dim);
  }

  .empty-state .icon { font-size: 42px; margin-bottom: 12px; opacity: 0.5; }
  .empty-state h3 { font-size: 17px; margin-bottom: 6px; color: var(--text); }
  .empty-state p { font-size: 14px; }

  .results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    font-size: 13px;
    color: var(--text-dim);
  }

  .result-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 18px 20px;
    margin-bottom: 10px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .result-card:hover {
    border-color: var(--accent);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  .result-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 6px;
  }

  .result-title { font-weight: 600; font-size: 15px; color: var(--text); }

  .result-score {
    font-family: var(--mono);
    font-size: 12px;
    padding: 2px 10px;
    border-radius: 12px;
    font-weight: 600;
    flex-shrink: 0;
    margin-left: 12px;
  }

  .score-high { background: rgba(34, 197, 94, 0.15); color: var(--green); }
  .score-mid { background: rgba(234, 179, 8, 0.15); color: var(--yellow); }
  .score-low { background: rgba(239, 68, 68, 0.15); color: var(--red); }

  .result-meta {
    display: flex;
    gap: 14px;
    font-size: 12px;
    color: var(--text-dim);
    margin-bottom: 8px;
    flex-wrap: wrap;
  }

  .result-snippet {
    font-size: 13px;
    color: var(--text-dim);
    line-height: 1.6;
    border-left: 2px solid var(--border);
    padding-left: 12px;
  }

  .result-snippet mark {
    background: var(--accent-glow);
    color: var(--accent);
    border-radius: 2px;
    padding: 0 2px;
  }

  .result-learn {
    margin-top: 10px;
    padding: 10px 14px;
    background: var(--surface-2);
    border-radius: 8px;
    font-size: 12px;
    color: var(--text-dim);
    line-height: 1.5;
    border-left: 2px solid var(--teal);
  }

  .result-learn strong { color: var(--teal); }

  .doc-detail {
    margin-top: 12px;
    padding-top: 14px;
    border-top: 1px solid var(--border);
    display: none;
  }

  .doc-detail.visible { display: block; }

  .doc-body {
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 18px;
    font-size: 13px;
    line-height: 1.7;
    color: var(--text);
    max-height: 380px;
    overflow-y: auto;
    white-space: pre-wrap;
    font-family: var(--mono);
  }

  .doc-chunks { margin-top: 10px; }

  .chunk-tag {
    display: inline-block;
    padding: 3px 10px;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 6px;
    font-size: 11px;
    font-family: var(--mono);
    color: var(--text-dim);
    margin: 2px 4px 2px 0;
  }

  .doc-learn {
    margin-top: 12px;
    padding: 12px 16px;
    background: rgba(20, 184, 166, 0.06);
    border: 1px solid rgba(20, 184, 166, 0.15);
    border-radius: 8px;
    font-size: 12px;
    color: var(--text-dim);
    line-height: 1.5;
  }

  .doc-learn strong { color: var(--teal); }

  /* ‚îÄ‚îÄ Loading / Error ‚îÄ‚îÄ */
  .loading { text-align: center; padding: 40px; color: var(--text-dim); }

  .spinner {
    width: 28px;
    height: 28px;
    border: 3px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin: 0 auto 12px;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .error-msg {
    text-align: center;
    padding: 20px;
    color: var(--red);
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.2);
    border-radius: var(--radius);
    font-family: var(--mono);
    font-size: 13px;
  }

  /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
  /* ‚îÄ‚îÄ About Page ‚îÄ‚îÄ */
  /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

  .about-hero {
    text-align: center;
    padding: 40px 0 32px;
    border-bottom: 1px solid var(--border);
    margin-bottom: 40px;
  }

  .about-hero h1 {
    font-size: 32px;
    font-weight: 700;
    margin-bottom: 10px;
    background: linear-gradient(135deg, var(--text), var(--accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .about-hero p {
    font-size: 16px;
    color: var(--text-dim);
    max-width: 640px;
    margin: 0 auto;
  }

  .about-section {
    margin-bottom: 48px;
  }

  .about-section h2 {
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 16px;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .about-section h2 .num {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    background: var(--accent);
    color: white;
    border-radius: 8px;
    font-size: 14px;
    flex-shrink: 0;
  }

  .about-section p, .about-section li {
    color: var(--text-dim);
    font-size: 15px;
    line-height: 1.7;
    margin-bottom: 10px;
  }

  .about-section ul {
    list-style: none;
    padding: 0;
  }

  .about-section li::before {
    content: '‚Üí ';
    color: var(--accent);
    font-weight: 700;
  }

  .about-section code {
    background: var(--surface-2);
    padding: 2px 7px;
    border-radius: 4px;
    font-family: var(--mono);
    font-size: 13px;
    color: var(--accent);
  }

  /* Pipeline diagram */
  .pipeline {
    display: flex;
    align-items: stretch;
    gap: 0;
    margin: 24px 0;
    overflow-x: auto;
    padding-bottom: 8px;
  }

  .pipe-step {
    flex: 1;
    min-width: 140px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 16px;
    text-align: center;
    position: relative;
  }

  .pipe-step::after {
    content: '‚Üí';
    position: absolute;
    right: -14px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--accent);
    font-size: 18px;
    font-weight: 700;
    z-index: 1;
  }

  .pipe-step:last-child::after { content: ''; }

  .pipe-step .step-icon { font-size: 24px; margin-bottom: 8px; }
  .pipe-step .step-title { font-size: 13px; font-weight: 700; color: var(--text); margin-bottom: 4px; }
  .pipe-step .step-desc { font-size: 11px; color: var(--text-dim); line-height: 1.4; }

  /* Concept cards */
  .concept-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 16px;
    margin-top: 16px;
  }

  .concept-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 20px;
  }

  .concept-card h3 {
    font-size: 15px;
    font-weight: 700;
    margin-bottom: 8px;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .concept-card p {
    font-size: 13px;
    color: var(--text-dim);
    line-height: 1.6;
    margin-bottom: 0;
  }

  .concept-card code {
    background: var(--surface-2);
    padding: 1px 5px;
    border-radius: 3px;
    font-family: var(--mono);
    font-size: 12px;
    color: var(--accent);
  }

  /* Code block in about */
  .about-code {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px 20px;
    font-family: var(--mono);
    font-size: 13px;
    color: var(--text);
    line-height: 1.6;
    overflow-x: auto;
    margin: 12px 0;
    white-space: pre;
  }

  .about-code .comment { color: var(--text-dim); }
  .about-code .cmd { color: var(--green); }
  .about-code .flag { color: var(--yellow); }

  /* Try it callout */
  .try-it {
    background: var(--accent-glow);
    border: 1px solid rgba(59, 130, 246, 0.25);
    border-radius: var(--radius);
    padding: 16px 20px;
    margin-top: 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .try-it:hover {
    border-color: var(--accent);
    transform: translateY(-1px);
  }

  .try-it .try-icon { font-size: 20px; }

  .try-it .try-text {
    font-size: 14px;
    color: var(--accent);
    font-weight: 600;
  }

  .try-it .try-sub {
    font-size: 12px;
    color: var(--text-dim);
    margin-top: 2px;
  }

  /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
  @media (max-width: 640px) {
    .container { padding: 16px; }
    .about-hero h1 { font-size: 24px; }
    .pipeline { flex-direction: column; gap: 8px; }
    .pipe-step::after { content: '‚Üì'; right: auto; left: 50%; top: auto; bottom: -14px; transform: translateX(-50%); }
    .result-header { flex-direction: column; gap: 6px; }
    .result-score { margin-left: 0; }
    .header-right { gap: 8px; }
  }
</style>
</head>
<body>

<header>
  <div class="logo">
    <div class="logo-icon">‚ö°</div>
    <span>Context Harness</span>
  </div>
  <div class="header-right">
    <div class="nav-tabs">
      <button class="nav-tab active" onclick="showPage('search')">Search</button>
      <button class="nav-tab" onclick="showPage('about')">About the Demo</button>
    </div>
    <div class="status-pill">
      <div class="status-dot" id="statusDot"></div>
      <span class="status-label" id="statusText">connecting‚Ä¶</span>
    </div>
  </div>
</header>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- SEARCH PAGE -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="page active" id="page-search">
<div class="container">

  <div class="learn-banner">
    <span class="banner-icon">üí°</span>
    <div>
      <strong>This is a live demo.</strong> Everything you see is powered by the Context Harness MCP server running locally. It has indexed 11 markdown documents from a fictional "Acme Engineering Handbook" into SQLite, chunked them, and serves results via HTTP. Hover the <span class="info-tip" style="display:inline-flex;position:static;vertical-align:middle;margin:0 2px;">?</span> icons for explanations.
    </div>
  </div>

  <!-- Search Input -->
  <div class="search-section">
    <div class="section-label">
      Query
      <span class="info-tip">?<span class="tip-text">Your search query is sent as a <strong>POST</strong> request to <code>/tools/search</code> on the MCP server. The server looks up matches in SQLite and returns ranked JSON results.</span></span>
    </div>
    <div class="search-box">
      <input type="text" class="search-input" id="searchInput"
             placeholder="Try: incident response, Kafka consumer lag, Rust error handling‚Ä¶"
             autocomplete="off">
      <button class="search-btn" onclick="doSearch()">Search</button>
    </div>

    <!-- Mode selector -->
    <div class="mode-section">
      <div class="section-label" style="margin-bottom:0">
        Mode
        <span class="info-tip">?<span class="tip-text">Context Harness supports three retrieval modes.<br><br><strong>keyword</strong> ‚Äî Full-text search (FTS5/BM25). Matches exact words.<br><strong>semantic</strong> ‚Äî Vector similarity using embeddings. Finds conceptually similar content even without matching words.<br><strong>hybrid</strong> ‚Äî Weighted combination of both, controlled by <code>hybrid_alpha</code>.</span></span>
      </div>
      <button class="mode-btn active" data-mode="keyword" onclick="setMode(this)">keyword</button>
      <button class="mode-btn" data-mode="semantic" id="btnSemantic" onclick="setMode(this)">semantic</button>
      <button class="mode-btn" data-mode="hybrid" id="btnHybrid" onclick="setMode(this)">hybrid</button>
      <select class="source-filter" id="sourceFilter">
        <option value="">all sources</option>
        <option value="filesystem">filesystem</option>
      </select>
    </div>

    <div class="embed-hint" id="embedHint">
      üîí semantic &amp; hybrid require embeddings ¬∑ set <code>[embedding] provider = "openai"</code> in config
    </div>

    <!-- Mode explainer (updates dynamically) -->
    <div class="mode-explainer" id="modeExplainer">
      <strong>Keyword mode</strong> ‚Äî Uses SQLite FTS5 with BM25 ranking. The query is matched against chunk text using full-text search. Results are ranked by term frequency and document length. This is fast and precise for known terms.
    </div>

    <!-- Stats bar -->
    <div class="stats-bar" id="statsBar">
      <div class="stat">results: <span class="stat-value" id="statCount">0</span>
        <span class="info-tip">?<span class="tip-text">The number of <strong>unique documents</strong> returned. Internally, the engine searches at the <em>chunk</em> level and then groups results back to documents using MAX score aggregation.</span></span>
      </div>
      <div class="stat">mode: <span class="stat-value" id="statMode">keyword</span></div>
      <div class="stat">time: <span class="stat-value" id="statTime">0ms</span>
        <span class="info-tip">?<span class="tip-text">Round-trip time from the browser to the MCP server and back. This includes: SQL query execution, BM25 scoring, score normalization, document grouping, and JSON serialization.</span></span>
      </div>
    </div>
  </div>

  <!-- Suggestions -->
  <div id="suggestionsArea">
    <div class="empty-state">
      <div class="icon">üîç</div>
      <h3>Search the Acme Engineering Handbook</h3>
      <p>Click a suggestion or type your own query:</p>
      <div class="suggestions">
        <button class="suggestion" onclick="trySuggestion(this)">incident response</button>
        <button class="suggestion" onclick="trySuggestion(this)">Kafka consumer lag</button>
        <button class="suggestion" onclick="trySuggestion(this)">Rust error handling</button>
        <button class="suggestion" onclick="trySuggestion(this)">deployment rollback</button>
        <button class="suggestion" onclick="trySuggestion(this)">on-call rotation</button>
        <button class="suggestion" onclick="trySuggestion(this)">API authentication</button>
        <button class="suggestion" onclick="trySuggestion(this)">data pipeline</button>
        <button class="suggestion" onclick="trySuggestion(this)">security breach</button>
      </div>
    </div>
  </div>

  <!-- Results -->
  <div class="results-area" id="resultsArea"></div>

</div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- ABOUT PAGE -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="page" id="page-about">
<div class="container">

  <div class="about-hero">
    <h1>About This Demo</h1>
    <p>An interactive walkthrough of how Context Harness ingests, indexes, and retrieves knowledge ‚Äî from markdown files to ranked search results.</p>
  </div>

  <!-- Section 1: What is Context Harness -->
  <div class="about-section">
    <h2><span class="num">1</span> What is Context Harness?</h2>
    <p>Context Harness is a <strong>local-first context ingestion and retrieval framework</strong> for AI tools. It solves a common problem: AI agents need access to your project knowledge (docs, runbooks, architecture decisions), but that knowledge is scattered across files, wikis, and tools.</p>
    <p>Context Harness provides a single pipeline that:</p>
    <ul>
      <li><strong>Connects</strong> to data sources (filesystem, GitHub, Jira, Slack)</li>
      <li><strong>Normalizes</strong> everything into a common Document model</li>
      <li><strong>Chunks</strong> documents into smaller pieces for precise retrieval</li>
      <li><strong>Embeds</strong> chunks as vectors for semantic search (optional)</li>
      <li><strong>Stores</strong> everything in a local SQLite database</li>
      <li><strong>Serves</strong> results via CLI and an MCP-compatible HTTP server</li>
    </ul>
  </div>

  <!-- Section 2: The Pipeline -->
  <div class="about-section">
    <h2><span class="num">2</span> The Ingestion Pipeline</h2>
    <p>When you run <code>ctx sync filesystem</code>, data flows through this pipeline:</p>
    <div class="pipeline">
      <div class="pipe-step">
        <div class="step-icon">üìÇ</div>
        <div class="step-title">Connector</div>
        <div class="step-desc">Walks the filesystem, applies glob patterns, reads files</div>
      </div>
      <div class="pipe-step">
        <div class="step-icon">üìã</div>
        <div class="step-title">Normalize</div>
        <div class="step-desc">Each file becomes a SourceItem with title, timestamps, metadata</div>
      </div>
      <div class="pipe-step">
        <div class="step-icon">‚úÇÔ∏è</div>
        <div class="step-title">Chunk</div>
        <div class="step-desc">Text is split into ~500-token chunks at paragraph boundaries</div>
      </div>
      <div class="pipe-step">
        <div class="step-icon">üß†</div>
        <div class="step-title">Embed</div>
        <div class="step-desc">Each chunk is converted to a vector via OpenAI (if enabled)</div>
      </div>
      <div class="pipe-step">
        <div class="step-icon">üíæ</div>
        <div class="step-title">Store</div>
        <div class="step-desc">Documents, chunks, FTS index, and vectors saved in SQLite</div>
      </div>
    </div>
    <p>In this demo, we indexed <strong>11 markdown documents</strong> from a fictional engineering handbook. The chunker produced <strong>~31 chunks</strong> ‚Äî these are the atomic units that get searched and ranked.</p>
  </div>

  <!-- Section 3: How Search Works -->
  <div class="about-section">
    <h2><span class="num">3</span> How Search Works</h2>
    <p>When you search, Context Harness doesn't just do a naive text match. Here's what happens under the hood:</p>

    <div class="concept-grid">
      <div class="concept-card">
        <h3>üî§ Keyword Search</h3>
        <p>Uses SQLite's <strong>FTS5</strong> extension with <strong>BM25</strong> ranking. BM25 scores documents based on term frequency (how often the word appears) normalized by document length. The query <code>"Kafka consumer lag"</code> matches chunks containing those exact terms.</p>
      </div>
      <div class="concept-card">
        <h3>üß† Semantic Search</h3>
        <p>Converts your query into a <strong>vector embedding</strong> (e.g., via OpenAI), then computes <strong>cosine similarity</strong> against all stored chunk vectors. This finds conceptually related content even without matching words ‚Äî "database crash" would match "PostgreSQL outage".</p>
      </div>
      <div class="concept-card">
        <h3>‚öñÔ∏è Hybrid Search</h3>
        <p>Combines keyword and semantic signals. Both score sets are <strong>min-max normalized</strong> to [0, 1], then merged with a weighted formula: <code>score = (1-Œ±)¬∑keyword + Œ±¬∑semantic</code>. The <code>hybrid_alpha</code> config controls the blend (0.6 = 60% semantic).</p>
      </div>
      <div class="concept-card">
        <h3>üìä Score Normalization</h3>
        <p>Raw BM25 scores and cosine similarities have different scales. Before merging, each set is normalized using <strong>min-max scaling</strong>: the best match gets 1.0, the worst gets 0.0, and everything else is linearly interpolated.</p>
      </div>
      <div class="concept-card">
        <h3>üìÑ Document Grouping</h3>
        <p>Search happens at the <strong>chunk level</strong>, but results are returned as <strong>documents</strong>. Multiple chunks from the same document are grouped together using <strong>MAX aggregation</strong> ‚Äî the document's score is its best chunk's score.</p>
      </div>
      <div class="concept-card">
        <h3>üîó MCP Server</h3>
        <p>The HTTP server exposes search, get, and sources as <strong>JSON endpoints</strong>. AI tools like Cursor can call these endpoints to query your knowledge base. The contract is defined in <code>SCHEMAS.md</code> ‚Äî every response matches that schema exactly.</p>
      </div>
    </div>

    <div class="try-it" onclick="showPage('search'); document.getElementById('searchInput').value='on-call rotation compensation'; doSearch();">
      <span class="try-icon">üöÄ</span>
      <div>
        <div class="try-text">Try it yourself</div>
        <div class="try-sub">Search for "on-call rotation compensation" and see how BM25 ranks the results</div>
      </div>
    </div>
  </div>

  <!-- Section 4: What's in the Knowledge Base -->
  <div class="about-section">
    <h2><span class="num">4</span> What's in the Knowledge Base</h2>
    <p>This demo indexes a fictional <strong>"Acme Engineering Handbook"</strong> ‚Äî 11 documents covering the kind of knowledge engineering teams produce:</p>

    <div class="concept-grid">
      <div class="concept-card">
        <h3>üìê Architecture Decisions</h3>
        <p>ADRs covering microservices, Kafka event-driven architecture, PostgreSQL selection, and Rust for performance-critical services.</p>
      </div>
      <div class="concept-card">
        <h3>üö® Incident Response</h3>
        <p>Severity levels, on-call rotation, incident templates, post-mortem process, and runbooks for common issues.</p>
      </div>
      <div class="concept-card">
        <h3>üöÄ Deployment Pipeline</h3>
        <p>CI/CD stages, canary deployments, rollback procedures, environment promotion, and deployment schedules.</p>
      </div>
      <div class="concept-card">
        <h3>üì° Observability Stack</h3>
        <p>Metrics (Datadog), structured logging, distributed tracing, SLOs, error budgets, and alerting policies.</p>
      </div>
      <div class="concept-card">
        <h3>üîí Security Practices</h3>
        <p>mTLS, Vault secrets management, PII handling, GDPR compliance, vulnerability management, and penetration testing.</p>
      </div>
      <div class="concept-card">
        <h3>ü¶Ä Rust Best Practices</h3>
        <p>Error handling patterns, async patterns with Tokio, testing strategies, performance tips, and approved crate list.</p>
      </div>
    </div>
  </div>

  <!-- Section 5: Architecture -->
  <div class="about-section">
    <h2><span class="num">5</span> System Architecture</h2>
    <p>Context Harness is written in <strong>Rust</strong> and compiles to a single binary called <code>ctx</code>. Here's how the pieces fit together:</p>

    <div class="about-code"><span class="comment"># Initialize the SQLite database (creates tables, FTS index)</span>
<span class="cmd">ctx</span> <span class="flag">init</span>

<span class="comment"># Sync a connector ‚Äî walks files, chunks, stores in SQLite</span>
<span class="cmd">ctx</span> <span class="flag">sync</span> filesystem

<span class="comment"># Search ‚Äî queries FTS5, ranks with BM25, returns JSON to stdout</span>
<span class="cmd">ctx</span> <span class="flag">search</span> "deployment rollback"

<span class="comment"># Start HTTP server ‚Äî same search engine, now via POST /tools/search</span>
<span class="cmd">ctx</span> <span class="flag">serve</span> mcp</div>

    <p>The server exposes three tool endpoints that match the <strong>MCP (Model Context Protocol)</strong> pattern:</p>
    <ul>
      <li><code>POST /tools/search</code> ‚Äî Search with query, mode, filters, and limit</li>
      <li><code>POST /tools/get</code> ‚Äî Retrieve a full document by ID (with all chunks)</li>
      <li><code>GET /tools/sources</code> ‚Äî List configured connectors and their health</li>
    </ul>
    <p>The CLI and server share the exact same core logic ‚Äî <code>search_documents()</code>, <code>get_document()</code>, and <code>get_sources()</code> return structured data that both the CLI printer and the HTTP handler consume.</p>
  </div>

  <!-- Section 6: Running it yourself -->
  <div class="about-section">
    <h2><span class="num">6</span> Run It Yourself</h2>
    <p>The full demo runs with a single command:</p>

    <div class="about-code"><span class="comment"># Clone, build, and run the demo</span>
<span class="cmd">git</span> clone https://github.com/parallax-labs/context-harness
<span class="cmd">cd</span> context-harness
<span class="cmd">./demo/demo.sh</span>

<span class="comment"># Or step by step:</span>
<span class="cmd">cargo</span> build --release
<span class="cmd">./target/release/ctx</span> <span class="flag">--config</span> demo/config/ctx.toml <span class="flag">init</span>
<span class="cmd">./target/release/ctx</span> <span class="flag">--config</span> demo/config/ctx.toml <span class="flag">sync</span> filesystem
<span class="cmd">./target/release/ctx</span> <span class="flag">--config</span> demo/config/ctx.toml <span class="flag">serve</span> mcp
<span class="comment"># Then open demo/ui/index.html in your browser</span></div>

    <p>To enable semantic and hybrid search, configure an OpenAI embedding provider in your config and set the <code>OPENAI_API_KEY</code> environment variable.</p>

    <div class="try-it" onclick="showPage('search');">
      <span class="try-icon">‚¨ÖÔ∏è</span>
      <div>
        <div class="try-text">Back to Search</div>
        <div class="try-sub">Try it out with the indexed Acme Engineering Handbook</div>
      </div>
    </div>
  </div>

</div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<!-- SCRIPT -->
<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<script>
const API = 'http://127.0.0.1:7331';
let currentMode = 'keyword';
let serverConnected = false;
let embeddingsEnabled = false;

const MODE_EXPLANATIONS = {
  keyword: '<strong>Keyword mode</strong> ‚Äî Uses SQLite FTS5 with BM25 ranking. The query is matched against chunk text using full-text search. Results are ranked by term frequency and document length. This is fast and precise for known terms. <em>Try searching for exact terms like "Kafka" or "rollback".</em>',
  semantic: '<strong>Semantic mode</strong> ‚Äî Your query is converted to a vector embedding, then compared against stored chunk vectors using cosine similarity. This finds conceptually related content even without matching words. <em>Requires [embedding] provider to be configured.</em>',
  hybrid: '<strong>Hybrid mode</strong> ‚Äî Combines keyword and semantic signals. Both score sets are min-max normalized to [0, 1], then merged: <code>score = (1-Œ±)¬∑keyword + Œ±¬∑semantic</code>. Default Œ±=0.6 gives 60% weight to semantic similarity. <em>Best of both worlds.</em>',
};

// ‚îÄ‚îÄ Navigation ‚îÄ‚îÄ
function showPage(page) {
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
  document.getElementById(`page-${page}`).classList.add('active');
  document.querySelector(`[onclick="showPage('${page}')"]`).classList.add('active');
  window.scrollTo(0, 0);
}

// ‚îÄ‚îÄ Health Check ‚îÄ‚îÄ
async function checkHealth() {
  try {
    const r = await fetch(`${API}/health`);
    const data = await r.json();
    document.getElementById('statusDot').classList.add('connected');
    serverConnected = true;

    const sr = await fetch(`${API}/tools/sources`);
    const sources = await sr.json();
    const configured = sources.sources.filter(s => s.configured).length;
    const total = sources.sources.length;

    // Probe embeddings
    const probe = await fetch(`${API}/tools/search`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: '__probe__', mode: 'semantic', limit: 1 }),
    });
    const probeData = await probe.json();
    embeddingsEnabled = probe.ok || probeData.error?.code !== 'embeddings_disabled';

    const modeLabel = embeddingsEnabled ? 'all modes' : 'keyword only';
    document.getElementById('statusText').textContent = `v${data.version} ¬∑ ${configured}/${total} sources ¬∑ ${modeLabel}`;
    updateModeButtons();
  } catch(e) {
    document.getElementById('statusDot').classList.remove('connected');
    document.getElementById('statusText').textContent = 'disconnected';
    serverConnected = false;
  }
}

function updateModeButtons() {
  const btnSemantic = document.getElementById('btnSemantic');
  const btnHybrid = document.getElementById('btnHybrid');
  const hint = document.getElementById('embedHint');

  if (embeddingsEnabled) {
    btnSemantic.classList.remove('disabled');
    btnHybrid.classList.remove('disabled');
    btnSemantic.textContent = 'semantic';
    btnHybrid.textContent = 'hybrid';
    hint.classList.remove('visible');
  } else {
    btnSemantic.classList.add('disabled');
    btnHybrid.classList.add('disabled');
    btnSemantic.innerHTML = 'semantic üîí';
    btnHybrid.innerHTML = 'hybrid üîí';
    hint.classList.add('visible');
    if (currentMode === 'semantic' || currentMode === 'hybrid') {
      currentMode = 'keyword';
      document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
      document.querySelector('[data-mode="keyword"]').classList.add('active');
      document.getElementById('modeExplainer').innerHTML = MODE_EXPLANATIONS.keyword;
    }
  }
}

function setMode(btn) {
  const mode = btn.dataset.mode;
  if (!embeddingsEnabled && (mode === 'semantic' || mode === 'hybrid')) {
    const hint = document.getElementById('embedHint');
    hint.classList.add('visible');
    hint.style.animation = 'none';
    hint.offsetHeight;
    hint.style.animation = 'flash 0.6s ease';
    return;
  }
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  currentMode = mode;
  document.getElementById('modeExplainer').innerHTML = MODE_EXPLANATIONS[mode];
}

function trySuggestion(btn) {
  document.getElementById('searchInput').value = btn.textContent;
  doSearch();
}

// ‚îÄ‚îÄ Search ‚îÄ‚îÄ
async function doSearch() {
  const query = document.getElementById('searchInput').value.trim();
  if (!query) return;

  const source = document.getElementById('sourceFilter').value;
  const area = document.getElementById('resultsArea');
  const suggestions = document.getElementById('suggestionsArea');

  suggestions.style.display = 'none';
  area.innerHTML = '<div class="loading"><div class="spinner"></div>Searching‚Ä¶</div>';
  document.getElementById('statsBar').classList.remove('visible');

  const t0 = performance.now();

  try {
    const body = { query, mode: currentMode, limit: 12 };
    if (source) body.filters = { source };

    const r = await fetch(`${API}/tools/search`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });

    const elapsed = Math.round(performance.now() - t0);

    if (!r.ok) {
      const err = await r.json();
      area.innerHTML = `<div class="error-msg">Error: ${err.error?.message || r.statusText}</div>`;
      return;
    }

    const data = await r.json();
    const results = data.results || [];

    document.getElementById('statsBar').classList.add('visible');
    document.getElementById('statCount').textContent = results.length;
    document.getElementById('statMode').textContent = currentMode;
    document.getElementById('statTime').textContent = `${elapsed}ms`;

    if (results.length === 0) {
      area.innerHTML = `<div class="empty-state"><div class="icon">üì≠</div><h3>No results</h3><p>Try different terms or switch to a broader query.</p></div>`;
      return;
    }

    area.innerHTML = `
      <div class="results-header">
        <span>${results.length} result${results.length !== 1 ? 's' : ''}</span>
        <span style="font-family:var(--mono)">${elapsed}ms</span>
      </div>
      ${results.map((r, i) => renderResult(r, i)).join('')}
      <div class="result-learn">
        <strong>üí° How these results were ranked:</strong> Each chunk in the database was scored using ${currentMode === 'keyword' ? 'BM25 (term frequency / document length)' : currentMode === 'semantic' ? 'cosine similarity against your query embedding' : 'a weighted merge of BM25 and cosine similarity'}. Chunks were then grouped by document (MAX score wins). Results are sorted by score descending, with ties broken by update date and document ID for deterministic ordering. Click any result to expand the full document and see its chunks.
      </div>`;
  } catch(e) {
    area.innerHTML = `<div class="error-msg">Cannot reach server at ${API}<br><br>Start: <strong>ctx serve mcp --config demo/config/ctx.toml</strong></div>`;
  }
}

function renderResult(r, idx) {
  const title = r.title || r.source_id || '(untitled)';
  const score = r.score.toFixed(2);
  const scoreClass = r.score >= 0.7 ? 'score-high' : r.score >= 0.4 ? 'score-mid' : 'score-low';
  const snippet = formatSnippet(r.snippet);
  const date = r.updated_at ? r.updated_at.split('T')[0] : '';

  const scoreExplain = r.score >= 0.7
    ? 'Strong match ‚Äî this chunk had high term overlap with your query'
    : r.score >= 0.4
    ? 'Moderate match ‚Äî some terms found but less concentrated'
    : 'Weak match ‚Äî few matching terms or only partial overlap';

  return `
    <div class="result-card" onclick="toggleDetail(${idx}, '${r.id}')">
      <div class="result-header">
        <span class="result-title">${escapeHtml(title)}</span>
        <span class="result-score ${scoreClass}" title="${scoreExplain}">${score}</span>
      </div>
      <div class="result-meta">
        <span>üìÅ ${escapeHtml(r.source)}</span>
        <span>üìÑ ${escapeHtml(r.source_id)}</span>
        ${date ? `<span>üìÖ ${date}</span>` : ''}
      </div>
      <div class="result-snippet">${snippet}</div>
      <div class="result-learn">
        <strong>Score ${score}:</strong> ${scoreExplain}. ${r.snippet && r.snippet.includes('>>>') ? 'The <mark>highlighted</mark> words are FTS5 match markers showing where your query terms were found in the chunk text.' : 'The snippet shows the beginning of the highest-scoring chunk from this document.'}
      </div>
      <div class="doc-detail" id="detail-${idx}"></div>
    </div>`;
}

function formatSnippet(text) {
  if (!text) return '';
  let s = escapeHtml(text);
  s = s.replace(/&gt;&gt;&gt;/g, '<mark>').replace(/&lt;&lt;&lt;/g, '</mark>');
  return s;
}

async function toggleDetail(idx, docId) {
  const el = document.getElementById(`detail-${idx}`);
  if (el.classList.contains('visible')) {
    el.classList.remove('visible');
    el.innerHTML = '';
    return;
  }

  el.innerHTML = '<div class="loading"><div class="spinner"></div>Loading document‚Ä¶</div>';
  el.classList.add('visible');

  try {
    const r = await fetch(`${API}/tools/get`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: docId }),
    });

    if (!r.ok) {
      el.innerHTML = '<div class="error-msg">Failed to load document</div>';
      return;
    }

    const doc = await r.json();

    el.innerHTML = `
      <div class="doc-learn">
        <strong>üí° What you're seeing:</strong> This is the full document retrieved via <code>POST /tools/get</code>. The document was split into <strong>${doc.chunks.length} chunk${doc.chunks.length !== 1 ? 's' : ''}</strong> during ingestion. Each chunk is a ~500-token segment split at paragraph boundaries. Search operates on these chunks individually, then groups results back to the parent document.
      </div>
      <div class="doc-chunks" style="margin-top:10px">
        ${doc.chunks.map(c => `<span class="chunk-tag">chunk ${c.index} ¬∑ ${c.text.length} chars</span>`).join('')}
      </div>
      <div class="doc-body">${escapeHtml(doc.body)}</div>
    `;
  } catch(e) {
    el.innerHTML = '<div class="error-msg">Connection error</div>';
  }
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

document.getElementById('searchInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') doSearch();
});

checkHealth();
setInterval(checkHealth, 15000);
</script>

</body>
</html>
