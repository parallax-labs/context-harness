<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Context Harness ‚Äî Documentation</title>
<meta name="description" content="Search and chat with Context Harness documentation ‚Äî guides, API reference, and architecture. Dogfooded with the Git connector and indexed by Context Harness itself.">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ö°</text></svg>">
<style>
:root {
  --bg: #0a0e17;
  --surface: #111827;
  --surface-2: #1a2332;
  --surface-3: #0f1a2a;
  --border: #1e2d3d;
  --text: #e2e8f0;
  --text-dim: #8892a4;
  --text-muted: #5a6478;
  --accent: #3b82f6;
  --accent-glow: rgba(59, 130, 246, 0.12);
  --green: #22c55e;
  --yellow: #eab308;
  --orange: #f97316;
  --purple: #a855f7;
  --teal: #14b8a6;
  --red: #ef4444;
  --radius: 12px;
  --mono: 'SF Mono', 'Fira Code', 'JetBrains Mono', monospace;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  line-height: 1.6;
}

/* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
header {
  border-bottom: 1px solid var(--border);
  padding: 14px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--surface);
  position: sticky;
  top: 0;
  z-index: 100;
}

.logo { display: flex; align-items: center; gap: 12px; font-weight: 700; font-size: 18px; text-decoration: none; color: var(--text); }
.logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--accent), var(--purple)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 16px; }

.header-right { display: flex; align-items: center; gap: 16px; }
.header-link { color: var(--text-dim); text-decoration: none; font-size: 14px; }
.header-link:hover { color: var(--accent); }

/* ‚îÄ‚îÄ Layout ‚îÄ‚îÄ */
.layout {
  display: grid;
  grid-template-columns: 260px 1fr;
  min-height: calc(100vh - 53px);
}

/* ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ */
.sidebar {
  border-right: 1px solid var(--border);
  background: var(--surface);
  padding: 20px 0;
  overflow-y: auto;
  position: sticky;
  top: 53px;
  height: calc(100vh - 53px);
}

.sidebar-section { padding: 0 16px; margin-bottom: 20px; }
.sidebar-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); margin-bottom: 8px; padding: 0 8px; }
.sidebar-link {
  display: flex; align-items: center; gap: 8px;
  padding: 6px 12px; border-radius: 6px;
  color: var(--text-dim); font-size: 13px; text-decoration: none;
  cursor: pointer; transition: all 0.15s;
}
.sidebar-link:hover { background: var(--surface-2); color: var(--text); }
.sidebar-link.active { background: var(--accent-glow); color: var(--accent); font-weight: 600; }

.sidebar-badge {
  margin-left: auto; font-size: 11px; padding: 1px 6px;
  border-radius: 10px; background: var(--surface-2); color: var(--text-muted);
  font-family: var(--mono);
}

.sidebar-divider { height: 1px; background: var(--border); margin: 12px 16px; }

/* ‚îÄ‚îÄ Main ‚îÄ‚îÄ */
.main { padding: 32px 40px; max-width: 900px; }

/* ‚îÄ‚îÄ Search ‚îÄ‚îÄ */
.search-container {
  position: relative; margin-bottom: 24px;
}
.search-input {
  width: 100%; padding: 14px 16px 14px 44px;
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); color: var(--text);
  font-size: 15px; font-family: inherit; outline: none;
  transition: border 0.2s, box-shadow 0.2s;
}
.search-input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow); }
.search-input::placeholder { color: var(--text-muted); }
.search-icon {
  position: absolute; left: 14px; top: 50%; transform: translateY(-50%);
  color: var(--text-muted); font-size: 18px; pointer-events: none;
}

.search-meta {
  display: flex; align-items: center; gap: 16px; margin-bottom: 16px;
  font-size: 13px; color: var(--text-dim);
}

.mode-pills { display: flex; gap: 4px; background: var(--surface); border-radius: 8px; padding: 3px; border: 1px solid var(--border); }
.mode-pill {
  padding: 5px 14px; border-radius: 6px; border: none;
  background: transparent; color: var(--text-dim);
  font-size: 12px; cursor: pointer; font-family: inherit; font-weight: 500;
  transition: all 0.2s;
}
.mode-pill:hover { color: var(--text); }
.mode-pill.active { background: var(--accent); color: white; }
.mode-pill[data-mode="chat"].active { background: var(--purple); }

.filter-pills { display: flex; gap: 4px; margin-left: auto; }
.filter-pill {
  padding: 4px 12px; border-radius: 14px; border: 1px solid var(--border);
  background: transparent; color: var(--text-dim);
  font-size: 12px; cursor: pointer; font-family: inherit;
  transition: all 0.2s;
}
.filter-pill:hover { border-color: var(--accent); color: var(--text); }
.filter-pill.active { border-color: var(--accent); background: var(--accent-glow); color: var(--accent); }

/* ‚îÄ‚îÄ Results ‚îÄ‚îÄ */
.result-count { font-size: 13px; color: var(--text-dim); margin-bottom: 16px; }

.result-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-bottom: 12px;
  cursor: pointer;
  transition: border-color 0.2s, transform 0.15s;
}
.result-card:hover { border-color: var(--accent); transform: translateY(-1px); }

.result-header {
  display: flex; align-items: flex-start; justify-content: space-between; margin-bottom: 8px;
}
.result-title { font-weight: 600; font-size: 15px; color: var(--text); }
.result-score {
  font-size: 12px; font-family: var(--mono); padding: 2px 8px;
  border-radius: 6px; font-weight: 600;
}
.score-high { background: rgba(34,197,94,0.15); color: var(--green); }
.score-mid  { background: rgba(234,179,8,0.15); color: var(--yellow); }
.score-low  { background: rgba(248,113,22,0.15); color: var(--orange); }

.result-meta {
  display: flex; gap: 12px; align-items: center; margin-bottom: 10px;
  font-size: 12px; color: var(--text-muted);
}
.result-tag {
  padding: 2px 8px; border-radius: 4px; font-size: 11px;
  font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em;
}
.tag-guide { background: rgba(59,130,246,0.15); color: var(--accent); }
.tag-api { background: rgba(168,85,247,0.15); color: var(--purple); }
.tag-meta { background: rgba(20,184,166,0.15); color: var(--teal); }

.result-snippet {
  font-size: 13px; line-height: 1.7; color: var(--text-dim);
  white-space: pre-wrap; font-family: var(--mono);
  max-height: 120px; overflow: hidden;
}
.result-snippet mark { background: var(--accent-glow); color: var(--accent); border-radius: 2px; padding: 0 2px; }

.result-source { font-size: 12px; color: var(--text-muted); margin-top: 8px; }
.result-source a { color: var(--accent); }

/* ‚îÄ‚îÄ Document View ‚îÄ‚îÄ */
.doc-view { display: none; }
.doc-view.active { display: block; }
.doc-back { color: var(--accent); font-size: 13px; text-decoration: none; cursor: pointer; display: inline-flex; align-items: center; gap: 6px; margin-bottom: 16px; }
.doc-back:hover { text-decoration: underline; }
.doc-title { font-size: 24px; font-weight: 700; margin-bottom: 8px; }
.doc-meta-bar { display: flex; gap: 12px; margin-bottom: 20px; font-size: 13px; color: var(--text-dim); }
.doc-body {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 24px;
  white-space: pre-wrap; font-family: var(--mono); font-size: 13px;
  line-height: 1.8; max-height: 70vh; overflow-y: auto;
}

/* ‚îÄ‚îÄ Welcome ‚îÄ‚îÄ */
.welcome { text-align: center; padding: 80px 24px; }
.welcome-title { font-size: 28px; font-weight: 700; margin-bottom: 12px; }
.welcome-sub { font-size: 15px; color: var(--text-dim); max-width: 500px; margin: 0 auto 24px; }
.welcome-badge {
  display: inline-flex; align-items: center; gap: 8px;
  padding: 6px 16px; border-radius: 20px;
  background: var(--surface); border: 1px solid var(--border);
  font-size: 12px; color: var(--text-dim); font-family: var(--mono);
}
.welcome-badge .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--green); }

/* ‚îÄ‚îÄ Loading ‚îÄ‚îÄ */
.loading-spinner {
  width: 32px; height: 32px; border: 3px solid var(--border);
  border-top-color: var(--accent); border-radius: 50%;
  animation: spin 0.8s linear infinite; margin: 40px auto;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* ‚îÄ‚îÄ Model Progress ‚îÄ‚îÄ */
.model-progress {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 16px; margin-bottom: 16px;
  display: none;
}
.model-progress.visible { display: block; }
.prog-bar { height: 4px; background: var(--surface-2); border-radius: 4px; overflow: hidden; margin-top: 8px; }
.prog-fill { height: 100%; background: var(--accent); transition: width 0.3s; width: 0; }
.prog-text { font-size: 12px; color: var(--text-dim); display: flex; justify-content: space-between; margin-top: 6px; }

/* ‚îÄ‚îÄ Empty ‚îÄ‚îÄ */
.empty-state { text-align: center; padding: 60px 24px; color: var(--text-dim); font-size: 14px; }

/* ============================
   Chat UI Styles
   ============================ */

.chat-container {
  display: none;
  flex-direction: column;
  height: calc(100vh - 53px - 64px);
  max-height: calc(100vh - 53px - 64px);
}
.chat-container.active { display: flex; }

/* Chat header bar */
.chat-header {
  display: flex; align-items: center; justify-content: space-between;
  padding-bottom: 16px; border-bottom: 1px solid var(--border); margin-bottom: 0;
  flex-shrink: 0;
}
.chat-header-left { display: flex; align-items: center; gap: 12px; }
.chat-header-title { font-size: 16px; font-weight: 600; }
.chat-backend-badge {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 3px 10px; border-radius: 12px;
  background: var(--surface-2); border: 1px solid var(--border);
  font-size: 11px; color: var(--text-dim); font-family: var(--mono);
}
.chat-backend-badge .bdot {
  width: 6px; height: 6px; border-radius: 50%;
}
.bdot-ready { background: var(--green); }
.bdot-loading { background: var(--yellow); animation: pulse-dot 1s infinite; }
.bdot-off { background: var(--text-muted); }
@keyframes pulse-dot { 0%,100%{opacity:1} 50%{opacity:0.4} }

.chat-actions { display: flex; align-items: center; gap: 8px; }
.chat-btn {
  padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border);
  background: transparent; color: var(--text-dim); font-size: 12px;
  cursor: pointer; font-family: inherit; transition: all 0.2s;
}
.chat-btn:hover { border-color: var(--accent); color: var(--text); }

/* Settings dropdown */
.settings-wrapper { position: relative; }
.settings-dropdown {
  display: none; position: absolute; top: calc(100% + 8px); right: 0;
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 16px; width: 320px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4); z-index: 200;
}
.settings-dropdown.open { display: block; }
.settings-label { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-muted); margin-bottom: 8px; }
.settings-radio-group { display: flex; flex-direction: column; gap: 6px; margin-bottom: 16px; }
.settings-radio {
  display: flex; align-items: center; gap: 10px; padding: 8px 12px;
  border-radius: 8px; border: 1px solid var(--border);
  cursor: pointer; transition: all 0.15s;
}
.settings-radio:hover { border-color: var(--accent); }
.settings-radio.selected { border-color: var(--accent); background: var(--accent-glow); }
.settings-radio input { display: none; }
.settings-radio-dot {
  width: 14px; height: 14px; border-radius: 50%; border: 2px solid var(--border);
  display: flex; align-items: center; justify-content: center; flex-shrink: 0;
}
.settings-radio.selected .settings-radio-dot { border-color: var(--accent); }
.settings-radio.selected .settings-radio-dot::after {
  content: ''; width: 6px; height: 6px; border-radius: 50%; background: var(--accent);
}
.settings-radio-info { flex: 1; }
.settings-radio-name { font-size: 13px; font-weight: 600; }
.settings-radio-desc { font-size: 11px; color: var(--text-dim); }

.settings-apikey-row { display: none; margin-bottom: 8px; }
.settings-apikey-row.visible { display: block; }
.settings-apikey-input {
  width: 100%; padding: 8px 12px; background: var(--surface-2);
  border: 1px solid var(--border); border-radius: 6px;
  color: var(--text); font-size: 13px; font-family: var(--mono);
  outline: none;
}
.settings-apikey-input:focus { border-color: var(--accent); }
.settings-hint { font-size: 11px; color: var(--text-muted); margin-top: 4px; }

/* Messages area */
.chat-messages {
  flex: 1; overflow-y: auto; padding: 20px 0;
  display: flex; flex-direction: column; gap: 16px;
}

.chat-msg {
  display: flex; gap: 12px; max-width: 100%;
}
.chat-msg-user { justify-content: flex-end; }
.chat-msg-assistant { justify-content: flex-start; }

.chat-avatar {
  width: 28px; height: 28px; border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  font-size: 14px; flex-shrink: 0;
}
.avatar-user { background: var(--accent); color: white; }
.avatar-assistant { background: linear-gradient(135deg, var(--purple), var(--accent)); color: white; }

.chat-bubble {
  padding: 12px 16px; border-radius: 12px; max-width: 85%;
  font-size: 14px; line-height: 1.7;
}
.bubble-user {
  background: var(--accent); color: white;
  border-bottom-right-radius: 4px;
}
.bubble-assistant {
  background: var(--surface); border: 1px solid var(--border);
  border-bottom-left-radius: 4px;
}

/* Markdown in assistant bubbles */
.bubble-assistant h1, .bubble-assistant h2, .bubble-assistant h3 {
  font-size: 15px; font-weight: 700; margin: 12px 0 4px 0; color: var(--text);
}
.bubble-assistant h1 { font-size: 17px; }
.bubble-assistant p { margin: 6px 0; }
.bubble-assistant ul, .bubble-assistant ol { margin: 6px 0 6px 20px; }
.bubble-assistant li { margin: 2px 0; }
.bubble-assistant code {
  background: var(--surface-2); padding: 1px 5px; border-radius: 4px;
  font-family: var(--mono); font-size: 12px; color: var(--accent);
}
.bubble-assistant pre {
  background: var(--surface-3); border: 1px solid var(--border);
  border-radius: 8px; padding: 12px; margin: 8px 0;
  overflow-x: auto; font-family: var(--mono); font-size: 12px;
  line-height: 1.5;
}
.bubble-assistant pre code {
  background: none; padding: 0; color: var(--text);
}
.bubble-assistant strong { color: var(--text); }
.bubble-assistant a { color: var(--accent); }
.bubble-assistant blockquote {
  border-left: 3px solid var(--accent); padding-left: 12px;
  margin: 8px 0; color: var(--text-dim);
}

/* Sources footer */
.chat-sources {
  margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border);
  font-size: 12px; color: var(--text-muted);
}
.chat-sources-title { font-weight: 600; margin-bottom: 4px; }
.chat-source-link {
  display: inline-block; margin-right: 8px; margin-bottom: 4px;
  padding: 2px 8px; border-radius: 4px; background: var(--surface-2);
  color: var(--accent); cursor: pointer; font-size: 11px;
  text-decoration: none; transition: background 0.15s;
}
.chat-source-link:hover { background: var(--accent-glow); }

/* Typing indicator */
.typing-indicator {
  display: flex; gap: 4px; padding: 8px 0;
}
.typing-indicator span {
  width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted);
  animation: typing-bounce 1.4s infinite;
}
.typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
.typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
@keyframes typing-bounce {
  0%,60%,100% { transform: translateY(0); opacity: 0.4; }
  30% { transform: translateY(-6px); opacity: 1; }
}

/* Chat welcome */
.chat-welcome { text-align: center; padding: 40px 24px; }
.chat-welcome-title { font-size: 22px; font-weight: 700; margin-bottom: 8px; }
.chat-welcome-sub { font-size: 14px; color: var(--text-dim); max-width: 460px; margin: 0 auto 20px; }
.chat-suggestions {
  display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: 16px;
}
.chat-suggestion {
  padding: 8px 16px; border-radius: 20px; border: 1px solid var(--border);
  background: var(--surface); color: var(--text-dim); font-size: 13px;
  cursor: pointer; transition: all 0.2s; font-family: inherit;
}
.chat-suggestion:hover { border-color: var(--accent); color: var(--text); }

/* Chat input bar */
.chat-input-bar {
  display: flex; gap: 8px; padding-top: 16px; border-top: 1px solid var(--border);
  flex-shrink: 0; align-items: flex-end;
}
.chat-input {
  flex: 1; padding: 12px 16px; background: var(--surface);
  border: 1px solid var(--border); border-radius: var(--radius);
  color: var(--text); font-size: 14px; font-family: inherit;
  outline: none; resize: none; min-height: 44px; max-height: 120px;
  transition: border 0.2s;
}
.chat-input:focus { border-color: var(--accent); }
.chat-input::placeholder { color: var(--text-muted); }
.chat-send {
  padding: 12px 20px; border-radius: var(--radius); border: none;
  background: var(--purple); color: white; font-size: 14px;
  cursor: pointer; font-family: inherit; font-weight: 600;
  transition: opacity 0.2s; height: 44px;
}
.chat-send:hover { opacity: 0.9; }
.chat-send:disabled { opacity: 0.4; cursor: not-allowed; }

/* LLM progress bar (in chat) */
.chat-llm-progress {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 12px 16px; margin-bottom: 12px;
  display: none; flex-shrink: 0;
}
.chat-llm-progress.visible { display: block; }

/* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
@media (max-width: 768px) {
  .layout { grid-template-columns: 1fr; }
  .sidebar { display: none; }
  .main { padding: 20px 16px; }
  .search-meta { flex-wrap: wrap; }
  .filter-pills { margin-left: 0; }
  .chat-bubble { max-width: 95%; }
  .settings-dropdown { width: 280px; right: -60px; }
}
</style>
</head>
<body>

<header>
  <a href="../" class="logo">
    <div class="logo-icon">‚ö°</div>
    <span>Context Harness <span style="font-weight:400;color:var(--text-dim)">Docs</span></span>
  </a>
  <div class="header-right">
    <a href="../demo/" class="header-link">Live Demo</a>
    <a href="../api/context_harness/" class="header-link">API Reference</a>
    <a href="https://github.com/parallax-labs/context-harness" class="header-link" target="_blank" rel="noopener">GitHub</a>
  </div>
</header>

<div class="layout">
  <aside class="sidebar" id="sidebar">
    <div class="sidebar-section">
      <div class="sidebar-title">Guides</div>
      <div id="sidebarGuides"></div>
    </div>
    <div class="sidebar-divider"></div>
    <div class="sidebar-section">
      <div class="sidebar-title">Reference</div>
      <div id="sidebarRef"></div>
    </div>
    <div class="sidebar-divider"></div>
    <div class="sidebar-section">
      <div class="sidebar-title">Source Modules</div>
      <div id="sidebarModules"></div>
    </div>
    <div class="sidebar-divider"></div>
    <div class="sidebar-section">
      <a href="../api/context_harness/" class="sidebar-link" target="_blank" rel="noopener">
        üìñ Full Rustdoc API
      </a>
    </div>
  </aside>

  <div class="main">
    <!-- Mode pills (shared between search and chat) -->
    <div class="search-meta" id="modePillsBar">
      <div class="mode-pills">
        <button class="mode-pill active" data-mode="keyword">Keyword</button>
        <button class="mode-pill" data-mode="semantic">Semantic</button>
        <button class="mode-pill" data-mode="hybrid">Hybrid</button>
        <button class="mode-pill" data-mode="chat">üí¨ Chat</button>
      </div>
    </div>

    <!-- Search page -->
    <div id="searchPage">
      <div class="search-container">
        <span class="search-icon">üîç</span>
        <input type="text" class="search-input" id="searchInput" placeholder="Search documentation‚Ä¶" autofocus>
      </div>

      <div class="search-meta">
        <div class="filter-pills">
          <button class="filter-pill active" data-filter="all">All</button>
          <button class="filter-pill" data-filter="guide">Guides</button>
          <button class="filter-pill" data-filter="api">API</button>
          <button class="filter-pill" data-filter="meta">Meta</button>
        </div>
      </div>

      <div id="modelProgress" class="model-progress">
        <span id="progDetail" style="font-size:13px;">Loading model‚Ä¶</span>
        <div class="prog-bar"><div class="prog-fill" id="progFill"></div></div>
        <div class="prog-text"><span id="progPct">0%</span></div>
      </div>

      <div id="resultCount" class="result-count"></div>
      <div id="searchResults"></div>

      <div id="welcomeState" class="welcome">
        <div class="welcome-title">Documentation Search</div>
        <div class="welcome-sub">
          Search across guides, API reference, and source code.
          This page is indexed by Context Harness itself ‚Äî dogfooding the Git connector.
        </div>
        <div class="welcome-badge">
          <span class="dot"></span>
          <span id="docStats">Loading‚Ä¶</span>
        </div>
      </div>
    </div>

    <!-- Chat page -->
    <div class="chat-container" id="chatPage">
      <div class="chat-header">
        <div class="chat-header-left">
          <span class="chat-header-title">Chat with Docs</span>
          <span class="chat-backend-badge" id="chatBackendBadge">
            <span class="bdot bdot-off" id="chatBdot"></span>
            <span id="chatBackendLabel">No backend</span>
          </span>
        </div>
        <div class="chat-actions">
          <button class="chat-btn" onclick="clearChat()">New Chat</button>
          <div class="settings-wrapper">
            <button class="chat-btn" id="settingsBtn">‚öô Settings</button>
            <div class="settings-dropdown" id="settingsDropdown">
              <div class="settings-label">Inference Backend</div>
              <div class="settings-radio-group">
                <label class="settings-radio selected" id="radioWebllm" onclick="selectBackend('webllm')">
                  <input type="radio" name="backend" value="webllm" checked>
                  <div class="settings-radio-dot"></div>
                  <div class="settings-radio-info">
                    <div class="settings-radio-name">üñ• WebLLM (Offline)</div>
                    <div class="settings-radio-desc">Runs Phi-3.5-mini in your browser via WebGPU. ~1.4GB download, cached for future visits. No API key needed.</div>
                  </div>
                </label>
                <label class="settings-radio" id="radioOpenai" onclick="selectBackend('openai')">
                  <input type="radio" name="backend" value="openai">
                  <div class="settings-radio-dot"></div>
                  <div class="settings-radio-info">
                    <div class="settings-radio-name">üîë OpenAI API</div>
                    <div class="settings-radio-desc">Uses gpt-4o-mini via your own API key. Key stays in your browser, never sent to our servers.</div>
                  </div>
                </label>
              </div>
              <div class="settings-apikey-row" id="apikeyRow">
                <div class="settings-label">OpenAI API Key</div>
                <input type="password" class="settings-apikey-input" id="apikeyInput" placeholder="sk-‚Ä¶">
                <div class="settings-hint">Stored in localStorage. Never leaves your browser.</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="chatLlmProgress" class="chat-llm-progress">
        <span id="chatProgDetail" style="font-size:13px;">Loading LLM‚Ä¶</span>
        <div class="prog-bar"><div class="prog-fill" id="chatProgFill"></div></div>
        <div class="prog-text"><span id="chatProgPct">0%</span></div>
      </div>

      <div class="chat-messages" id="chatMessages">
        <div class="chat-welcome" id="chatWelcome">
          <div class="chat-welcome-title">Ask anything about Context Harness</div>
          <div class="chat-welcome-sub">
            I'll search the documentation, find the relevant sections, and explain them to you.
            Choose a backend in Settings ‚Äî WebLLM runs fully offline, or paste an OpenAI key for faster responses.
          </div>
          <div class="chat-suggestions" id="chatSuggestions">
            <button class="chat-suggestion" onclick="askSuggestion(this)">How do I set up the Git connector?</button>
            <button class="chat-suggestion" onclick="askSuggestion(this)">What is hybrid search?</button>
            <button class="chat-suggestion" onclick="askSuggestion(this)">How do embeddings work?</button>
            <button class="chat-suggestion" onclick="askSuggestion(this)">Explain the MCP server endpoints</button>
          </div>
        </div>
      </div>

      <div class="chat-input-bar">
        <textarea class="chat-input" id="chatInput" placeholder="Ask a question about the docs‚Ä¶" rows="1"></textarea>
        <button class="chat-send" id="chatSend" onclick="sendChatMessage()">Send</button>
      </div>
    </div>

    <!-- Document view -->
    <div id="docView" class="doc-view">
      <a class="doc-back" onclick="showSearch()">‚Üê Back to results</a>
      <h1 class="doc-title" id="docTitle"></h1>
      <div class="doc-meta-bar" id="docMeta"></div>
      <pre class="doc-body" id="docBody"></pre>
    </div>
  </div>
</div>

<script>
/* ====================================================================
   Context Harness Documentation ‚Äî Client-Side Search + Chat
   Uses BM25 for keyword search, Transformers.js for semantic search,
   and WebLLM/OpenAI for RAG-powered chat.
   Data is pre-indexed in CI via the Git connector.
   ==================================================================== */

let DATA = { documents: [], chunks: [] };
let currentMode = 'keyword';
let currentFilter = 'all';

// Semantic search state
let pipeline = null;
let modelReady = false;
let modelLoading = false;
let chunkEmbeddings = [];
let _modelPromise = null;

// ‚îÄ‚îÄ Data Loading ‚îÄ‚îÄ
async function init() {
  try {
    const resp = await fetch('data.json');
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    DATA = await resp.json();
  } catch (e) {
    document.getElementById('docStats').textContent = 'data.json not found ‚Äî run scripts/build-docs.sh first';
    return;
  }

  document.getElementById('docStats').textContent =
    `${DATA.documents.length} documents ¬∑ ${DATA.chunks.length} chunks ¬∑ indexed via Git connector`;

  buildSidebar();
  buildIndex();

  // Try to load cached embeddings
  if (loadCachedEmbeddings()) {
    modelReady = true;
    _modelPromise = loadModel().catch(e => console.warn('Background model load:', e));
  }

  // Restore chat settings
  initChatSettings();
}

// ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ
function classifyDoc(sourceId) {
  if (sourceId.startsWith('docs/')) return 'guide';
  if (sourceId.startsWith('src/')) return 'api';
  return 'meta';
}

function buildSidebar() {
  const guides = [], refs = [], modules = [];

  DATA.documents.forEach(d => {
    const kind = classifyDoc(d.source_id);
    const title = d.title || d.source_id;
    const entry = { id: d.id, title, sourceId: d.source_id };
    if (kind === 'guide') guides.push(entry);
    else if (kind === 'api') modules.push(entry);
    else refs.push(entry);
  });

  const renderList = (items, container) => {
    container.innerHTML = items.map(item =>
      `<a class="sidebar-link" onclick="viewDocument('${item.id}')" title="${item.sourceId}">${item.title}</a>`
    ).join('');
  };

  renderList(guides, document.getElementById('sidebarGuides'));
  renderList(refs, document.getElementById('sidebarRef'));
  renderList(modules, document.getElementById('sidebarModules'));
}

// ‚îÄ‚îÄ BM25 Index ‚îÄ‚îÄ
let bm25Index = {};
let avgDl = 0;
const BM25_K1 = 1.2, BM25_B = 0.75;

function tokenize(text) {
  return text.toLowerCase().replace(/[^\w\s]/g, ' ').split(/\s+/).filter(t => t.length > 1);
}

function buildIndex() {
  const N = DATA.chunks.length;
  const dl = [];
  const tf = [];
  const df = {};

  DATA.chunks.forEach((chunk, i) => {
    const tokens = tokenize(chunk.text);
    dl.push(tokens.length);
    const freq = {};
    tokens.forEach(t => { freq[t] = (freq[t] || 0) + 1; });
    tf.push(freq);
    const seen = new Set(tokens);
    seen.forEach(t => { df[t] = (df[t] || 0) + 1; });
  });

  avgDl = dl.reduce((a, b) => a + b, 0) / (N || 1);
  bm25Index = { N, dl, tf, df };
}

function bm25Search(query) {
  const qTokens = tokenize(query);
  if (qTokens.length === 0) return [];

  const { N, dl, tf, df } = bm25Index;
  const scores = [];

  for (let i = 0; i < N; i++) {
    let score = 0;
    for (const qt of qTokens) {
      const tfi = tf[i][qt] || 0;
      if (tfi === 0) continue;
      const dfi = df[qt] || 0;
      const idf = Math.log((N - dfi + 0.5) / (dfi + 0.5) + 1);
      const num = tfi * (BM25_K1 + 1);
      const denom = tfi + BM25_K1 * (1 - BM25_B + BM25_B * dl[i] / avgDl);
      score += idf * num / denom;
    }
    if (score > 0) scores.push({ idx: i, score });
  }

  scores.sort((a, b) => b.score - a.score);
  return scores.slice(0, 20).map(s => chunkToResult(s.idx, s.score));
}

function chunkToResult(chunkIdx, rawScore) {
  const chunk = DATA.chunks[chunkIdx];
  const doc = DATA.documents.find(d => d.id === chunk.document_id);

  return {
    id: doc?.id || '',
    title: doc?.title || '',
    source: doc?.source || 'git',
    source_id: doc?.source_id || '',
    source_url: doc?.source_url || '',
    updated_at: doc?.updated_at || 0,
    score: Math.min(rawScore / (rawScore + 2), 1),
    snippet: chunk.text.substring(0, 300),
    chunk_index: chunk.chunk_index,
    text: chunk.text,
  };
}

// ‚îÄ‚îÄ Semantic Search ‚îÄ‚îÄ
function loadCachedEmbeddings() {
  try {
    const hash = DATA.chunks.map(c => c.id).join(',');
    if (localStorage.getItem('ctx_docs_hash') === hash) {
      const cached = JSON.parse(localStorage.getItem('ctx_docs_embeddings'));
      if (cached && cached.length === DATA.chunks.length) {
        chunkEmbeddings = cached;
        return true;
      }
    }
  } catch (e) { /* ignore */ }
  return false;
}

async function loadModel() {
  if (_modelPromise) return _modelPromise;

  _modelPromise = (async () => {
    modelLoading = true;
    const prog = document.getElementById('modelProgress');
    prog.classList.add('visible');

    try {
      const { pipeline: createPipeline, env } = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.5.1');
      env.allowLocalModels = false;

      document.getElementById('progDetail').textContent = 'Initializing model‚Ä¶';
      document.getElementById('progFill').style.width = '20%';
      document.getElementById('progPct').textContent = '20%';

      pipeline = await createPipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2', {
        progress_callback: (p) => {
          if (p.status === 'progress' && p.progress) {
            const pct = Math.round(20 + p.progress * 0.4);
            document.getElementById('progFill').style.width = pct + '%';
            document.getElementById('progPct').textContent = pct + '%';
            document.getElementById('progDetail').textContent = `Downloading model: ${p.file || ''}`;
          }
        }
      });

      document.getElementById('progDetail').textContent = `Embedding ${DATA.chunks.length} chunks‚Ä¶`;
      document.getElementById('progFill').style.width = '60%';
      document.getElementById('progPct').textContent = '60%';

      chunkEmbeddings = [];
      for (let i = 0; i < DATA.chunks.length; i++) {
        const result = await pipeline(DATA.chunks[i].text, { pooling: 'mean', normalize: true });
        chunkEmbeddings.push(Array.from(result.data));
        const pct = Math.round(60 + (i / DATA.chunks.length) * 40);
        document.getElementById('progFill').style.width = pct + '%';
        document.getElementById('progPct').textContent = pct + '%';
        document.getElementById('progDetail').textContent = `Embedding chunk ${i + 1}/${DATA.chunks.length}‚Ä¶`;
      }

      try {
        localStorage.setItem('ctx_docs_embeddings', JSON.stringify(chunkEmbeddings));
        localStorage.setItem('ctx_docs_hash', DATA.chunks.map(c => c.id).join(','));
      } catch (e) { /* storage full */ }

      modelReady = true;
      document.getElementById('progFill').style.width = '100%';
      document.getElementById('progPct').textContent = '100%';
      document.getElementById('progDetail').textContent = 'Ready!';
      setTimeout(() => prog.classList.remove('visible'), 2000);
      return true;
    } catch (e) {
      document.getElementById('progDetail').textContent = `Error: ${e.message}`;
      document.getElementById('progFill').style.background = 'var(--red)';
      modelLoading = false;
      _modelPromise = null;
      throw e;
    }
  })();

  return _modelPromise;
}

function cosineSim(a, b) {
  let dot = 0, na = 0, nb = 0;
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i];
    na += a[i] * a[i];
    nb += b[i] * b[i];
  }
  return dot / (Math.sqrt(na) * Math.sqrt(nb) + 1e-8);
}

async function semanticSearch(query) {
  const result = await pipeline(query, { pooling: 'mean', normalize: true });
  const qVec = Array.from(result.data);

  const scores = [];
  for (let i = 0; i < DATA.chunks.length; i++) {
    const sim = cosineSim(qVec, chunkEmbeddings[i]);
    if (sim > 0.1) scores.push({ idx: i, score: sim });
  }
  scores.sort((a, b) => b.score - a.score);
  return scores.slice(0, 20).map(s => chunkToResult(s.idx, s.score));
}

async function hybridSearch(query, topK = 20) {
  const kw = bm25Search(query);
  const sem = modelReady ? await semanticSearch(query) : [];

  const normalize = (arr) => {
    if (arr.length === 0) return [];
    const scores = arr.map(r => r.score);
    const min = Math.min(...scores), max = Math.max(...scores);
    const range = max - min || 1;
    return arr.map(r => ({ ...r, score: (r.score - min) / range }));
  };

  const alpha = sem.length > 0 ? 0.6 : 0;
  const kwNorm = normalize(kw);
  const semNorm = normalize(sem);
  const merged = {};

  kwNorm.forEach(r => {
    const key = r.id + ':' + r.chunk_index;
    merged[key] = { ...r, score: (1 - alpha) * r.score };
  });
  semNorm.forEach(r => {
    const key = r.id + ':' + r.chunk_index;
    if (merged[key]) merged[key].score += alpha * r.score;
    else merged[key] = { ...r, score: alpha * r.score };
  });

  return Object.values(merged).sort((a, b) => b.score - a.score).slice(0, topK);
}

// ‚îÄ‚îÄ Search Execution ‚îÄ‚îÄ
let debounceTimer;
const searchInput = document.getElementById('searchInput');

searchInput.addEventListener('input', () => {
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(doSearch, 200);
});

searchInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') { clearTimeout(debounceTimer); doSearch(); }
});

async function doSearch() {
  const query = searchInput.value.trim();
  if (!query) {
    document.getElementById('searchResults').innerHTML = '';
    document.getElementById('resultCount').textContent = '';
    document.getElementById('welcomeState').style.display = 'block';
    return;
  }

  document.getElementById('welcomeState').style.display = 'none';
  const area = document.getElementById('searchResults');
  area.innerHTML = '<div class="loading-spinner"></div>';
  document.getElementById('resultCount').textContent = 'Searching‚Ä¶';

  const start = performance.now();

  try {
    let results = [];
    if (currentMode === 'keyword') {
      results = bm25Search(query);
    } else if (currentMode === 'semantic') {
      if (!modelReady) await loadModel();
      results = await semanticSearch(query);
    } else if (currentMode === 'hybrid') {
      if (!modelReady) await loadModel();
      results = await hybridSearch(query);
    }

    // Apply filter
    if (currentFilter !== 'all') {
      results = results.filter(r => classifyDoc(r.source_id) === currentFilter);
    }

    const elapsed = (performance.now() - start).toFixed(0);
    document.getElementById('resultCount').textContent =
      `${results.length} result${results.length !== 1 ? 's' : ''} in ${elapsed}ms`;

    if (results.length === 0) {
      area.innerHTML = '<div class="empty-state">No results found. Try different terms or search mode.</div>';
      return;
    }

    area.innerHTML = results.map((r, i) => renderResult(r, query)).join('');
  } catch (e) {
    area.innerHTML = `<div class="empty-state" style="color:var(--red)">Search error: ${e.message}</div>`;
    document.getElementById('resultCount').textContent = 'Error';
    console.error('Search failed:', e);
  }
}

function renderResult(r, query) {
  const score = r.score.toFixed(2);
  const scoreClass = r.score >= 0.7 ? 'score-high' : r.score >= 0.4 ? 'score-mid' : 'score-low';
  const kind = classifyDoc(r.source_id);
  const tagClass = kind === 'guide' ? 'tag-guide' : kind === 'api' ? 'tag-api' : 'tag-meta';
  const tagLabel = kind === 'guide' ? 'Guide' : kind === 'api' ? 'Source' : 'Meta';

  let date = '';
  if (r.updated_at) {
    if (typeof r.updated_at === 'string') date = r.updated_at.split('T')[0];
    else if (typeof r.updated_at === 'number') date = new Date(r.updated_at * 1000).toISOString().split('T')[0];
  }

  let snippet = escapeHtml(r.snippet);
  if (query) {
    const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 1);
    terms.forEach(term => {
      const re = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      snippet = snippet.replace(re, '<mark>$1</mark>');
    });
  }

  return `
    <div class="result-card" onclick="viewDocument('${r.id}')">
      <div class="result-header">
        <span class="result-title">${escapeHtml(r.title)}</span>
        <span class="result-score ${scoreClass}">${score}</span>
      </div>
      <div class="result-meta">
        <span class="result-tag ${tagClass}">${tagLabel}</span>
        <span>${r.source_id}</span>
        ${date ? `<span>${date}</span>` : ''}
      </div>
      <div class="result-snippet">${snippet}</div>
      ${r.source_url ? `<div class="result-source"><a href="${escapeHtml(r.source_url)}" target="_blank" rel="noopener" onclick="event.stopPropagation()">View source ‚Üí</a></div>` : ''}
    </div>
  `;
}

function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ‚îÄ‚îÄ Document View ‚îÄ‚îÄ
function viewDocument(id) {
  const doc = DATA.documents.find(d => d.id === id);
  if (!doc) return;

  document.getElementById('searchPage').style.display = 'none';
  document.getElementById('chatPage').classList.remove('active');
  document.getElementById('docView').classList.add('active');

  document.getElementById('docTitle').textContent = doc.title || doc.source_id;

  const kind = classifyDoc(doc.source_id);
  let date = '';
  if (doc.updated_at) {
    if (typeof doc.updated_at === 'number') date = new Date(doc.updated_at * 1000).toISOString().split('T')[0];
    else date = String(doc.updated_at).split('T')[0];
  }

  document.getElementById('docMeta').innerHTML = `
    <span class="result-tag ${kind === 'guide' ? 'tag-guide' : kind === 'api' ? 'tag-api' : 'tag-meta'}">${kind}</span>
    <span>${doc.source_id}</span>
    ${date ? `<span>${date}</span>` : ''}
    ${doc.source_url ? `<a href="${escapeHtml(doc.source_url)}" target="_blank" rel="noopener" style="color:var(--accent)">View on GitHub ‚Üí</a>` : ''}
  `;

  document.getElementById('docBody').textContent = doc.body;
  document.querySelectorAll('.sidebar-link').forEach(el => el.classList.remove('active'));
}

function showSearch() {
  document.getElementById('docView').classList.remove('active');
  if (currentMode === 'chat') {
    document.getElementById('chatPage').classList.add('active');
    document.getElementById('searchPage').style.display = 'none';
  } else {
    document.getElementById('searchPage').style.display = 'block';
    document.getElementById('chatPage').classList.remove('active');
    searchInput.focus();
  }
}

// ‚îÄ‚îÄ Mode & Filter Pills ‚îÄ‚îÄ
document.querySelectorAll('.mode-pill').forEach(pill => {
  pill.addEventListener('click', () => {
    document.querySelectorAll('.mode-pill').forEach(p => p.classList.remove('active'));
    pill.classList.add('active');
    currentMode = pill.dataset.mode;

    document.getElementById('docView').classList.remove('active');

    if (currentMode === 'chat') {
      document.getElementById('searchPage').style.display = 'none';
      document.getElementById('chatPage').classList.add('active');
      document.getElementById('chatInput').focus();
    } else {
      document.getElementById('chatPage').classList.remove('active');
      document.getElementById('searchPage').style.display = 'block';
      searchInput.focus();
      doSearch();
    }
  });
});

document.querySelectorAll('.filter-pill').forEach(pill => {
  pill.addEventListener('click', () => {
    document.querySelectorAll('.filter-pill').forEach(p => p.classList.remove('active'));
    pill.classList.add('active');
    currentFilter = pill.dataset.filter;
    doSearch();
  });
});

// ‚îÄ‚îÄ Keyboard Shortcut ‚îÄ‚îÄ
document.addEventListener('keydown', (e) => {
  if (e.key === '/' && document.activeElement !== searchInput && document.activeElement !== document.getElementById('chatInput')) {
    e.preventDefault();
    if (currentMode === 'chat') document.getElementById('chatInput').focus();
    else searchInput.focus();
  }
  if (e.key === 'Escape') {
    if (document.getElementById('docView').classList.contains('active')) showSearch();
    const dd = document.getElementById('settingsDropdown');
    if (dd.classList.contains('open')) dd.classList.remove('open');
  }
});

/* ====================================================================
   CHAT SYSTEM
   ==================================================================== */

let chatHistory = []; // { role: 'user'|'assistant', content: string, sources?: [] }
let chatBackend = 'webllm'; // 'webllm' | 'openai'
let webllmEngine = null;
let webllmReady = false;
let webllmLoading = false;
let _webllmPromise = null;
let chatGenerating = false;

// ‚îÄ‚îÄ Chat Settings ‚îÄ‚îÄ
function initChatSettings() {
  // Restore backend choice
  const saved = localStorage.getItem('ctx_chat_backend');
  if (saved === 'openai' || saved === 'webllm') {
    chatBackend = saved;
  }

  // Restore API key
  const key = localStorage.getItem('ctx_chat_apikey');
  if (key) document.getElementById('apikeyInput').value = key;

  updateBackendUI();

  // Settings toggle
  document.getElementById('settingsBtn').addEventListener('click', (e) => {
    e.stopPropagation();
    document.getElementById('settingsDropdown').classList.toggle('open');
  });

  document.addEventListener('click', (e) => {
    const dd = document.getElementById('settingsDropdown');
    if (dd.classList.contains('open') && !dd.contains(e.target) && e.target !== document.getElementById('settingsBtn')) {
      dd.classList.remove('open');
    }
  });

  // API key input
  document.getElementById('apikeyInput').addEventListener('input', (e) => {
    const key = e.target.value.trim();
    if (key) localStorage.setItem('ctx_chat_apikey', key);
    else localStorage.removeItem('ctx_chat_apikey');
    updateBackendUI();
  });

  // Chat input auto-resize
  const chatInput = document.getElementById('chatInput');
  chatInput.addEventListener('input', () => {
    chatInput.style.height = 'auto';
    chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
  });
  chatInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendChatMessage();
    }
  });
}

function selectBackend(backend) {
  chatBackend = backend;
  localStorage.setItem('ctx_chat_backend', backend);

  document.getElementById('radioWebllm').classList.toggle('selected', backend === 'webllm');
  document.getElementById('radioOpenai').classList.toggle('selected', backend === 'openai');
  document.getElementById('apikeyRow').classList.toggle('visible', backend === 'openai');

  updateBackendUI();
}

function updateBackendUI() {
  const bdot = document.getElementById('chatBdot');
  const label = document.getElementById('chatBackendLabel');

  if (chatBackend === 'webllm') {
    document.getElementById('radioWebllm').classList.add('selected');
    document.getElementById('radioOpenai').classList.remove('selected');
    document.getElementById('apikeyRow').classList.remove('visible');

    if (webllmReady) {
      bdot.className = 'bdot bdot-ready';
      label.textContent = 'WebLLM ready';
    } else if (webllmLoading) {
      bdot.className = 'bdot bdot-loading';
      label.textContent = 'Loading model‚Ä¶';
    } else {
      bdot.className = 'bdot bdot-off';
      label.textContent = 'WebLLM (click Send to load)';
      // Check WebGPU support
      if (!navigator.gpu) {
        label.textContent = 'WebGPU not supported ‚Äî use API key';
        bdot.className = 'bdot bdot-off';
      }
    }
  } else {
    document.getElementById('radioOpenai').classList.add('selected');
    document.getElementById('radioWebllm').classList.remove('selected');
    document.getElementById('apikeyRow').classList.add('visible');

    const key = localStorage.getItem('ctx_chat_apikey');
    if (key) {
      bdot.className = 'bdot bdot-ready';
      label.textContent = 'OpenAI API ready';
    } else {
      bdot.className = 'bdot bdot-off';
      label.textContent = 'Enter API key';
    }
  }
}

// ‚îÄ‚îÄ WebLLM Backend ‚îÄ‚îÄ
async function ensureWebLLM() {
  if (webllmReady && webllmEngine) return webllmEngine;
  if (_webllmPromise) return _webllmPromise;

  if (!navigator.gpu) {
    throw new Error('WebGPU is not supported in this browser. Please use Chrome/Edge 113+ or switch to the OpenAI API backend.');
  }

  _webllmPromise = (async () => {
    webllmLoading = true;
    updateBackendUI();

    const prog = document.getElementById('chatLlmProgress');
    prog.classList.add('visible');

    try {
      const webllm = await import('https://esm.run/@mlc-ai/web-llm');

      const modelId = 'Phi-3.5-mini-instruct-q4f16_1-MLC';

      document.getElementById('chatProgDetail').textContent = 'Loading Phi-3.5-mini‚Ä¶';
      document.getElementById('chatProgFill').style.width = '5%';
      document.getElementById('chatProgPct').textContent = '5%';

      webllmEngine = await webllm.CreateMLCEngine(modelId, {
        initProgressCallback: (report) => {
          const pct = Math.round((report.progress || 0) * 100);
          document.getElementById('chatProgFill').style.width = pct + '%';
          document.getElementById('chatProgPct').textContent = pct + '%';
          document.getElementById('chatProgDetail').textContent = report.text || 'Loading‚Ä¶';
        }
      });

      webllmReady = true;
      webllmLoading = false;
      updateBackendUI();

      document.getElementById('chatProgFill').style.width = '100%';
      document.getElementById('chatProgPct').textContent = '100%';
      document.getElementById('chatProgDetail').textContent = 'Model ready!';
      setTimeout(() => prog.classList.remove('visible'), 1500);

      return webllmEngine;
    } catch (e) {
      webllmLoading = false;
      _webllmPromise = null;
      updateBackendUI();

      document.getElementById('chatProgDetail').textContent = `Error: ${e.message}`;
      document.getElementById('chatProgFill').style.background = 'var(--red)';
      throw e;
    }
  })();

  return _webllmPromise;
}

// ‚îÄ‚îÄ RAG Pipeline ‚îÄ‚îÄ
async function retrieveContext(query) {
  // Use hybrid search (BM25 + semantic if available) to find relevant chunks
  const results = await hybridSearch(query, 5);

  // Deduplicate by document
  const seen = new Set();
  const unique = [];
  for (const r of results) {
    const key = r.id + ':' + r.chunk_index;
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(r);
    }
  }

  return unique.slice(0, 5);
}

function buildSystemPrompt(contextChunks) {
  let contextBlock = '';
  if (contextChunks.length === 0) {
    contextBlock = '(No relevant documentation found for this question.)';
  } else {
    contextBlock = contextChunks.map((c, i) =>
      `### Source ${i + 1}: ${c.source_id}\n${c.text}`
    ).join('\n\n');
  }

  return `You are a documentation assistant for Context Harness, a local-first context indexing and retrieval framework for AI tools written in Rust.

Answer the user's question using ONLY the documentation excerpts provided below. Be concise, accurate, and helpful. Use markdown formatting for code blocks, lists, and emphasis.

If the answer is not in the provided documentation, say "I don't have enough context to answer that fully" and suggest what the user could search for or which documentation section might help.

When referencing information, mention the source filename naturally (e.g. "According to USAGE.md..." or "The search module shows...").

## Documentation Context

${contextBlock}`;
}

function buildMessages(systemPrompt, history) {
  const msgs = [{ role: 'system', content: systemPrompt }];

  // Keep last 6 user/assistant exchanges for context
  const recent = history.slice(-12);
  for (const msg of recent) {
    msgs.push({ role: msg.role, content: msg.content });
  }

  return msgs;
}

// ‚îÄ‚îÄ Markdown Renderer ‚îÄ‚îÄ
function renderMarkdown(text) {
  let html = escapeHtml(text);

  // Code blocks: ```lang\ncode\n```
  html = html.replace(/```(\w*)\n([\s\S]*?)```/g, (_, lang, code) => {
    return `<pre><code>${code.trim()}</code></pre>`;
  });

  // Inline code
  html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

  // Headers
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

  // Bold and italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // Blockquotes
  html = html.replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>');

  // Unordered lists
  html = html.replace(/^- (.+)$/gm, '<li>$1</li>');
  html = html.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');

  // Ordered lists
  html = html.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');

  // Links
  html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');

  // Paragraphs: split on double newlines
  html = html.replace(/\n\n/g, '</p><p>');
  html = '<p>' + html + '</p>';

  // Clean up empty paragraphs and fix nesting
  html = html.replace(/<p>\s*<(h[123]|pre|ul|ol|blockquote)/g, '<$1');
  html = html.replace(/<\/(h[123]|pre|ul|ol|blockquote)>\s*<\/p>/g, '</$1>');
  html = html.replace(/<p>\s*<\/p>/g, '');

  return html;
}

// ‚îÄ‚îÄ Chat Message Rendering ‚îÄ‚îÄ
function appendUserMessage(text) {
  const welcome = document.getElementById('chatWelcome');
  if (welcome) welcome.remove();

  const container = document.getElementById('chatMessages');
  const div = document.createElement('div');
  div.className = 'chat-msg chat-msg-user';
  div.innerHTML = `
    <div class="chat-bubble bubble-user">${escapeHtml(text)}</div>
    <div class="chat-avatar avatar-user">U</div>
  `;
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
}

function createAssistantBubble() {
  const container = document.getElementById('chatMessages');
  const div = document.createElement('div');
  div.className = 'chat-msg chat-msg-assistant';
  div.innerHTML = `
    <div class="chat-avatar avatar-assistant">‚ö°</div>
    <div class="chat-bubble bubble-assistant">
      <div class="typing-indicator"><span></span><span></span><span></span></div>
    </div>
  `;
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;

  return div.querySelector('.bubble-assistant');
}

function updateAssistantBubble(bubble, text, sources) {
  bubble.innerHTML = renderMarkdown(text);

  if (sources && sources.length > 0) {
    const srcDiv = document.createElement('div');
    srcDiv.className = 'chat-sources';
    srcDiv.innerHTML = `
      <div class="chat-sources-title">Sources</div>
      ${sources.map(s =>
        `<a class="chat-source-link" onclick="viewDocument('${s.id}')" title="${s.source_id}">${s.source_id}</a>`
      ).join('')}
    `;
    bubble.appendChild(srcDiv);
  }

  const container = document.getElementById('chatMessages');
  container.scrollTop = container.scrollHeight;
}

// ‚îÄ‚îÄ Send Message ‚îÄ‚îÄ
async function sendChatMessage() {
  const input = document.getElementById('chatInput');
  const query = input.value.trim();
  if (!query || chatGenerating) return;

  chatGenerating = true;
  document.getElementById('chatSend').disabled = true;
  input.value = '';
  input.style.height = 'auto';

  // Add user message
  appendUserMessage(query);
  chatHistory.push({ role: 'user', content: query });

  // Create assistant bubble with typing indicator
  const bubble = createAssistantBubble();

  try {
    // RAG: retrieve relevant context
    const contextChunks = await retrieveContext(query);
    const systemPrompt = buildSystemPrompt(contextChunks);
    const messages = buildMessages(systemPrompt, chatHistory);

    // Stream response from selected backend
    let fullResponse = '';

    if (chatBackend === 'openai') {
      fullResponse = await streamOpenAI(messages, bubble);
    } else {
      fullResponse = await streamWebLLM(messages, bubble);
    }

    // Finalize with sources
    updateAssistantBubble(bubble, fullResponse, contextChunks);
    chatHistory.push({ role: 'assistant', content: fullResponse, sources: contextChunks });

  } catch (e) {
    bubble.innerHTML = `<div style="color:var(--red)">Error: ${escapeHtml(e.message)}</div>`;
    console.error('Chat error:', e);
  }

  chatGenerating = false;
  document.getElementById('chatSend').disabled = false;
  input.focus();
}

// ‚îÄ‚îÄ OpenAI Streaming ‚îÄ‚îÄ
async function streamOpenAI(messages, bubble) {
  const apiKey = localStorage.getItem('ctx_chat_apikey');
  if (!apiKey) throw new Error('No OpenAI API key configured. Open Settings to add one.');

  const resp = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model: 'gpt-4o-mini',
      messages,
      stream: true,
      max_tokens: 1024,
      temperature: 0.3,
    }),
  });

  if (!resp.ok) {
    const err = await resp.text();
    throw new Error(`OpenAI API error (${resp.status}): ${err}`);
  }

  const reader = resp.body.getReader();
  const decoder = new TextDecoder();
  let fullText = '';
  let buffer = '';

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed === 'data: [DONE]') continue;
      if (!trimmed.startsWith('data: ')) continue;

      try {
        const json = JSON.parse(trimmed.slice(6));
        const delta = json.choices?.[0]?.delta?.content;
        if (delta) {
          fullText += delta;
          bubble.innerHTML = renderMarkdown(fullText) + '<span style="opacity:0.4">‚ñå</span>';
          const container = document.getElementById('chatMessages');
          container.scrollTop = container.scrollHeight;
        }
      } catch (e) { /* skip malformed lines */ }
    }
  }

  return fullText;
}

// ‚îÄ‚îÄ WebLLM Streaming ‚îÄ‚îÄ
async function streamWebLLM(messages, bubble) {
  const engine = await ensureWebLLM();

  let fullText = '';

  const completion = await engine.chat.completions.create({
    messages,
    stream: true,
    max_tokens: 1024,
    temperature: 0.3,
  });

  for await (const chunk of completion) {
    const delta = chunk.choices?.[0]?.delta?.content;
    if (delta) {
      fullText += delta;
      bubble.innerHTML = renderMarkdown(fullText) + '<span style="opacity:0.4">‚ñå</span>';
      const container = document.getElementById('chatMessages');
      container.scrollTop = container.scrollHeight;
    }
  }

  return fullText;
}

// ‚îÄ‚îÄ Chat Utilities ‚îÄ‚îÄ
function clearChat() {
  chatHistory = [];
  const container = document.getElementById('chatMessages');
  container.innerHTML = `
    <div class="chat-welcome" id="chatWelcome">
      <div class="chat-welcome-title">Ask anything about Context Harness</div>
      <div class="chat-welcome-sub">
        I'll search the documentation, find the relevant sections, and explain them to you.
        Choose a backend in Settings ‚Äî WebLLM runs fully offline, or paste an OpenAI key for faster responses.
      </div>
      <div class="chat-suggestions" id="chatSuggestions">
        <button class="chat-suggestion" onclick="askSuggestion(this)">How do I set up the Git connector?</button>
        <button class="chat-suggestion" onclick="askSuggestion(this)">What is hybrid search?</button>
        <button class="chat-suggestion" onclick="askSuggestion(this)">How do embeddings work?</button>
        <button class="chat-suggestion" onclick="askSuggestion(this)">Explain the MCP server endpoints</button>
      </div>
    </div>
  `;
}

function askSuggestion(btn) {
  const text = btn.textContent;
  document.getElementById('chatInput').value = text;
  sendChatMessage();
}

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ
init();
</script>
</body>
</html>
