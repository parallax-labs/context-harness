<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation — Context Harness</title>
    <meta name="description" content="Context Harness documentation — local-first context indexing and retrieval for AI tools.">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⚡</text></svg>">
    <style>
        /* ===== Reset ===== */
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0a0a0f;
            --bg-card: #12121a;
            --bg-card-hover: #1a1a25;
            --bg-sidebar: #0e0e16;
            --text: #e4e4ec;
            --text-dim: #8888a0;
            --text-muted: #55556a;
            --accent: #4f8fff;
            --accent-bright: #6ba3ff;
            --accent-glow: rgba(79, 143, 255, 0.12);
            --green: #4ade80;
            --yellow: #facc15;
            --red: #f87171;
            --orange: #fb923c;
            --border: #1e1e2e;
            --border-light: #2a2a3a;
            --radius: 8px;
            --font: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-mono: 'JetBrains Mono', 'SF Mono', 'Fira Code', monospace;
            --sidebar-w: 260px;
            --header-h: 56px;
        }

        html { scroll-behavior: smooth; scroll-padding-top: calc(var(--header-h) + 24px); }

        body {
            font-family: var(--font);
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
            -webkit-font-smoothing: antialiased;
        }

        a { color: var(--accent); text-decoration: none; }
        a:hover { color: var(--accent-bright); text-decoration: underline; }

        /* ===== Header ===== */
        .header {
            position: fixed; top: 0; left: 0; right: 0; z-index: 100;
            height: var(--header-h);
            background: rgba(10, 10, 15, 0.92);
            backdrop-filter: blur(16px);
            border-bottom: 1px solid var(--border);
            display: flex; align-items: center; padding: 0 24px;
        }
        .header-inner {
            width: 100%; max-width: 1400px; margin: 0 auto;
            display: flex; align-items: center; justify-content: space-between;
        }
        .header-left { display: flex; align-items: center; gap: 16px; }
        .header-brand {
            display: flex; align-items: center; gap: 8px;
            color: var(--text); font-weight: 700; font-size: 16px;
        }
        .header-brand:hover { text-decoration: none; color: var(--text); }
        .header-sep { color: var(--text-muted); font-size: 18px; font-weight: 300; }
        .header-title { color: var(--text-dim); font-size: 14px; font-weight: 500; }
        .header-links { display: flex; align-items: center; gap: 20px; }
        .header-links a {
            color: var(--text-dim); font-size: 13px; font-weight: 500;
        }
        .header-links a:hover { color: var(--text); text-decoration: none; }
        .header-links .gh-link {
            display: flex; align-items: center; opacity: 0.7;
        }
        .header-links .gh-link:hover { opacity: 1; }
        .menu-btn {
            display: none; background: none; border: none; color: var(--text);
            font-size: 22px; cursor: pointer; padding: 4px;
        }
        .header-search {
            display: flex; align-items: center; gap: 6px;
            padding: 6px 12px; border-radius: 8px; cursor: pointer;
            background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.1);
            color: var(--text-muted); font-size: 13px; transition: all 0.15s;
        }
        .header-search:hover { border-color: rgba(255,255,255,0.2); color: var(--text-dim); }
        .header-search kbd {
            padding: 1px 5px; border-radius: 3px; font-size: 11px;
            background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1);
        }

        /* ===== Layout ===== */
        .layout {
            display: flex;
            margin-top: var(--header-h);
            min-height: calc(100vh - var(--header-h));
        }

        /* ===== Sidebar ===== */
        .sidebar {
            position: fixed; top: var(--header-h); left: 0; bottom: 0;
            width: var(--sidebar-w);
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border);
            overflow-y: auto; padding: 20px 0;
            scrollbar-width: thin;
            scrollbar-color: var(--border-light) transparent;
        }
        .sidebar::-webkit-scrollbar { width: 4px; }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border-light); border-radius: 4px; }

        .nav-group { margin-bottom: 20px; }
        .nav-group-title {
            padding: 0 20px; margin-bottom: 6px;
            font-size: 11px; font-weight: 700; text-transform: uppercase;
            letter-spacing: 1.2px; color: var(--text-muted);
        }
        .nav-link {
            display: block; padding: 5px 20px 5px 24px;
            font-size: 13px; color: var(--text-dim);
            border-left: 2px solid transparent;
            transition: all 0.15s;
        }
        .nav-link:hover {
            color: var(--text); background: rgba(255,255,255,0.02);
            text-decoration: none;
        }
        .nav-link.active {
            color: var(--accent); border-left-color: var(--accent);
            background: var(--accent-glow);
        }

        /* ===== Content ===== */
        .content {
            flex: 1; margin-left: var(--sidebar-w);
            padding: 40px 48px 80px;
            max-width: 840px;
        }

        .content h1 {
            font-size: 32px; font-weight: 800; letter-spacing: -0.5px;
            margin-bottom: 8px; line-height: 1.3;
        }
        .content h2 {
            font-size: 22px; font-weight: 700; margin-top: 56px; margin-bottom: 16px;
            padding-bottom: 8px; border-bottom: 1px solid var(--border);
        }
        .content h3 {
            font-size: 17px; font-weight: 700; margin-top: 36px; margin-bottom: 12px;
            color: var(--text);
        }
        .content h4 {
            font-size: 14px; font-weight: 700; margin-top: 24px; margin-bottom: 8px;
            color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px;
        }
        .content p { margin-bottom: 16px; color: var(--text-dim); font-size: 15px; }
        .content ul, .content ol {
            margin-bottom: 16px; padding-left: 24px; color: var(--text-dim); font-size: 15px;
        }
        .content li { margin-bottom: 6px; }
        .content strong { color: var(--text); font-weight: 600; }
        .content em { color: var(--accent); font-style: normal; }

        .lead { font-size: 17px; color: var(--text-dim); margin-bottom: 32px; line-height: 1.8; }

        /* ===== Code ===== */
        code {
            font-family: var(--font-mono); font-size: 0.88em;
            background: var(--bg-card); padding: 2px 7px; border-radius: 4px;
            color: var(--accent-bright);
        }
        pre {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 16px 20px;
            overflow-x: auto; margin-bottom: 20px;
            font-size: 13px; line-height: 1.75;
        }
        pre code {
            background: none; padding: 0; color: var(--text-dim); font-size: 13px;
        }
        .prompt { color: var(--green); user-select: none; }
        .comment { color: var(--text-muted); }
        .key { color: var(--orange); }
        .val { color: var(--green); }
        .str { color: var(--green); }

        /* ===== Tables ===== */
        table {
            width: 100%; border-collapse: collapse; margin-bottom: 20px;
            font-size: 14px;
        }
        th {
            text-align: left; padding: 10px 14px;
            background: var(--bg-card); border: 1px solid var(--border);
            font-weight: 600; color: var(--text); font-size: 13px;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        td {
            padding: 10px 14px; border: 1px solid var(--border);
            color: var(--text-dim);
        }
        td code { font-size: 12px; }

        /* ===== Callouts ===== */
        .callout {
            padding: 16px 20px; border-radius: var(--radius);
            margin-bottom: 20px; font-size: 14px;
            border-left: 3px solid;
        }
        .callout-info {
            background: rgba(79, 143, 255, 0.06);
            border-color: var(--accent);
        }
        .callout-info p { color: var(--text-dim); margin: 0; }
        .callout-warn {
            background: rgba(250, 204, 21, 0.06);
            border-color: var(--yellow);
        }
        .callout-warn p { color: var(--text-dim); margin: 0; }

        /* ===== Section anchor ===== */
        .section { scroll-margin-top: calc(var(--header-h) + 24px); }

        /* ===== Responsive ===== */
        @media (max-width: 900px) {
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.25s ease;
                z-index: 90;
            }
            .sidebar.open { transform: translateX(0); }
            .content { margin-left: 0; padding: 32px 20px 60px; }
            .menu-btn { display: block; }
            .header-title { display: none; }
        }
    </style>
</head>
<body>

<!-- ===== HEADER ===== -->
<header class="header">
    <div class="header-inner">
        <div class="header-left">
            <button class="menu-btn" onclick="document.querySelector('.sidebar').classList.toggle('open')" aria-label="Menu">☰</button>
            <a href="../" class="header-brand">⚡ Context Harness</a>
            <span class="header-sep">/</span>
            <span class="header-title">Documentation</span>
        </div>
        <div class="header-links">
            <button class="header-search" id="search-trigger">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="11" cy="11" r="7"/><path d="m21 21-4.35-4.35"/></svg>
                Search
                <kbd>⌘K</kbd>
            </button>
            <a href="../">Home</a>
            <a href="../api/context_harness/">API Reference</a>
            <a href="https://github.com/parallax-labs/context-harness" class="gh-link" target="_blank" rel="noopener">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
            </a>
        </div>
    </div>
</header>

<!-- ===== SIDEBAR ===== -->
<div class="layout">
<nav class="sidebar" id="sidebar">
    <div class="nav-group">
        <div class="nav-group-title">Getting Started</div>
        <a class="nav-link active" href="#overview">Overview</a>
        <a class="nav-link" href="#installation">Installation</a>
        <a class="nav-link" href="#quick-start">Quick Start</a>
    </div>
    <div class="nav-group">
        <div class="nav-group-title">Configuration</div>
        <a class="nav-link" href="#configuration">Config File</a>
        <a class="nav-link" href="#connectors">Connectors</a>
        <a class="nav-link" href="#connector-filesystem">Filesystem</a>
        <a class="nav-link" href="#connector-git">Git</a>
        <a class="nav-link" href="#connector-s3">S3</a>
        <a class="nav-link" href="#embedding-config">Embeddings</a>
    </div>
    <div class="nav-group">
        <div class="nav-group-title">CLI Reference</div>
        <a class="nav-link" href="#cli">Commands</a>
        <a class="nav-link" href="#cli-init">init</a>
        <a class="nav-link" href="#cli-sync">sync</a>
        <a class="nav-link" href="#cli-search">search</a>
        <a class="nav-link" href="#cli-get">get</a>
        <a class="nav-link" href="#cli-embed">embed</a>
        <a class="nav-link" href="#cli-sources">sources</a>
        <a class="nav-link" href="#cli-serve">serve mcp</a>
    </div>
    <div class="nav-group">
        <div class="nav-group-title">HTTP API</div>
        <a class="nav-link" href="#api">Endpoints</a>
        <a class="nav-link" href="#api-search">POST /tools/search</a>
        <a class="nav-link" href="#api-get">POST /tools/get</a>
        <a class="nav-link" href="#api-sources">GET /tools/sources</a>
        <a class="nav-link" href="#api-errors">Error Handling</a>
    </div>
    <div class="nav-group">
        <div class="nav-group-title">Search &amp; Retrieval</div>
        <a class="nav-link" href="#search">How Search Works</a>
        <a class="nav-link" href="#hybrid-scoring">Hybrid Scoring</a>
    </div>
    <div class="nav-group">
        <div class="nav-group-title">Integration</div>
        <a class="nav-link" href="#cursor">Cursor / MCP</a>
        <a class="nav-link" href="#ci-cd">CI/CD Pipelines</a>
    </div>
    <div class="nav-group">
        <div class="nav-group-title">Deployment</div>
        <a class="nav-link" href="#deployment">Overview</a>
        <a class="nav-link" href="#deploy-binary">Single Binary</a>
        <a class="nav-link" href="#deploy-docker">Docker</a>
        <a class="nav-link" href="#deploy-systemd">Systemd</a>
    </div>
    <div class="nav-group">
        <div class="nav-group-title">Reference</div>
        <a class="nav-link" href="#architecture">Architecture</a>
        <a class="nav-link" href="#env-vars">Environment Variables</a>
        <a class="nav-link" href="#contributing">Contributing</a>
    </div>
</nav>

<!-- ===== MAIN CONTENT ===== -->
<main class="content">

<!-- ==================== OVERVIEW ==================== -->
<section class="section" id="overview">
<h1>Context Harness</h1>
<p class="lead">
    A local-first context indexing framework that ingests documentation and code from any source,
    stores it in SQLite, and exposes it to AI tools via CLI and MCP-compatible HTTP server.
    One binary. Zero cloud dependencies. Designed for CI pipelines and static knowledge bases.
</p>

<p>Context Harness solves a specific problem: <strong>getting the right context to AI agents</strong>. Point it at your docs, source code, or S3 bucket. It chunks, indexes, and optionally embeds everything into a local SQLite database. Then expose that knowledge via the <code>ctx</code> CLI or the MCP server — Cursor, Claude, and any MCP-compatible tool can search your project knowledge instantly.</p>

<h3>What it's for</h3>
<ul>
    <li><strong>CI-built knowledge bases</strong> — index your repo in CI, deploy the database as an artifact</li>
    <li><strong>MCP context provider</strong> — give Cursor/Claude structured retrieval over your codebase</li>
    <li><strong>Static docs search</strong> — replace Algolia with self-hosted search, no API keys needed</li>
    <li><strong>Engineering onboarding</strong> — index ADRs, runbooks, incident reports into a searchable knowledge base</li>
</ul>

<h3>Key features</h3>
<ul>
    <li><strong>Connector-driven ingestion</strong> — filesystem, Git repos, S3 buckets (more coming)</li>
    <li><strong>Hybrid retrieval</strong> — keyword (FTS5/BM25) + semantic (cosine similarity) + weighted merge</li>
    <li><strong>Incremental sync</strong> — checkpointed, idempotent, deterministic</li>
    <li><strong>Single binary</strong> — SQLite is embedded, no runtime dependencies</li>
    <li><strong>MCP server</strong> — HTTP API for AI tool integration</li>
</ul>
</section>

<!-- ==================== INSTALLATION ==================== -->
<section class="section" id="installation">
<h2>Installation</h2>

<h3>From source (recommended)</h3>
<pre><code><span class="prompt">$</span> cargo install --path .

<span class="comment"># Or directly from the repository</span>
<span class="prompt">$</span> cargo install --git https://github.com/parallax-labs/context-harness</code></pre>

<h3>Build manually</h3>
<pre><code><span class="prompt">$</span> git clone https://github.com/parallax-labs/context-harness.git
<span class="prompt">$</span> cd context-harness
<span class="prompt">$</span> cargo build --release
<span class="prompt">$</span> ./target/release/ctx --help</code></pre>

<h3>Prerequisites</h3>
<table>
    <tr><th>Tool</th><th>Version</th><th>Required For</th></tr>
    <tr><td>Rust</td><td>1.75+ (stable)</td><td>Building the <code>ctx</code> binary</td></tr>
    <tr><td>Git</td><td>2.x</td><td>Git connector</td></tr>
</table>

<p>SQLite is bundled — no system install needed.</p>
</section>

<!-- ==================== QUICK START ==================== -->
<section class="section" id="quick-start">
<h2>Quick Start</h2>

<h3>1. Create a config file</h3>
<pre><code><span class="prompt">$</span> cp config/ctx.example.toml config/ctx.toml</code></pre>

<p>Edit <code>config/ctx.toml</code> to point at your documentation:</p>

<pre><code><span class="key">[db]</span>
path = <span class="val">"./data/ctx.sqlite"</span>

<span class="key">[chunking]</span>
max_tokens = <span class="val">700</span>

<span class="key">[retrieval]</span>
final_limit = <span class="val">12</span>

<span class="key">[server]</span>
bind = <span class="val">"127.0.0.1:7331"</span>

<span class="key">[connectors.filesystem]</span>
root = <span class="val">"./docs"</span>
include_globs = [<span class="val">"**/*.md"</span>, <span class="val">"**/*.rs"</span>]</code></pre>

<h3>2. Initialize and sync</h3>
<pre><code><span class="prompt">$</span> ctx init --config ./config/ctx.toml
<span class="comment"># Database initialized successfully.</span>

<span class="prompt">$</span> ctx sync filesystem --config ./config/ctx.toml
<span class="comment"># sync filesystem
#   fetched: 47 items
#   upserted documents: 47
#   chunks written: 203
# ok</span></code></pre>

<h3>3. Search</h3>
<pre><code><span class="prompt">$</span> ctx search "authentication" --config ./config/ctx.toml
<span class="comment"># 1. [0.94] filesystem / auth-module.rs
#    JWT signing key loaded from AWS Secrets Manager...
# 2. [0.81] filesystem / deployment-runbook.md
#    Key rotation procedure for production services...</span></code></pre>

<h3>4. Start the MCP server</h3>
<pre><code><span class="prompt">$</span> ctx serve mcp --config ./config/ctx.toml
<span class="comment"># Listening on 127.0.0.1:7331</span></code></pre>

<p>Your knowledge base is now queryable by Cursor, Claude, or any HTTP client.</p>
</section>

<!-- ==================== CONFIGURATION ==================== -->
<section class="section" id="configuration">
<h2>Configuration</h2>

<p>Context Harness uses a TOML config file passed via <code>--config</code>. See <a href="https://github.com/parallax-labs/context-harness/blob/main/config/ctx.example.toml">ctx.example.toml</a> for a complete annotated example.</p>

<h3>Full reference</h3>
<pre><code><span class="key">[db]</span>
path = <span class="val">"./data/ctx.sqlite"</span>          <span class="comment"># SQLite database file path</span>

<span class="key">[chunking]</span>
max_tokens = <span class="val">700</span>                    <span class="comment"># Max tokens per chunk (~4 chars/token)</span>
overlap_tokens = <span class="val">80</span>                  <span class="comment"># Overlap between consecutive chunks</span>

<span class="key">[embedding]</span>
provider = <span class="val">"disabled"</span>                <span class="comment"># "disabled" or "openai"</span>
<span class="comment"># model = "text-embedding-3-small"  # Required when provider != "disabled"</span>
<span class="comment"># dims = 1536                       # Embedding dimensions</span>
<span class="comment"># batch_size = 64                   # Texts per API call</span>
<span class="comment"># max_retries = 5                   # Retry count for API failures</span>
<span class="comment"># timeout_secs = 30                 # Per-request timeout</span>

<span class="key">[retrieval]</span>
final_limit = <span class="val">12</span>                     <span class="comment"># Max results returned</span>
hybrid_alpha = <span class="val">0.6</span>                   <span class="comment"># 0.0 = keyword only, 1.0 = semantic only</span>
candidate_k_keyword = <span class="val">80</span>             <span class="comment"># FTS candidates to fetch</span>
candidate_k_vector = <span class="val">80</span>              <span class="comment"># Vector candidates to fetch</span>
group_by = <span class="val">"document"</span>                <span class="comment"># Group results by document</span>
doc_agg = <span class="val">"max"</span>                      <span class="comment"># Aggregation: max chunk score</span>
max_chunks_per_doc = <span class="val">3</span>               <span class="comment"># Max chunks per document in results</span>

<span class="key">[server]</span>
bind = <span class="val">"127.0.0.1:7331"</span>             <span class="comment"># HTTP server bind address</span></code></pre>
</section>

<!-- ==================== CONNECTORS ==================== -->
<section class="section" id="connectors">
<h2>Connectors</h2>

<p>Connectors fetch data from external sources and normalize it into a consistent <code>Document</code> model. All connectors support incremental sync via checkpoints — only changed content is re-processed on subsequent runs.</p>
</section>

<!-- Filesystem -->
<section class="section" id="connector-filesystem">
<h3>Filesystem Connector</h3>

<p>Scan a local directory tree for files matching glob patterns.</p>

<pre><code><span class="key">[connectors.filesystem]</span>
root = <span class="val">"./docs"</span>                      <span class="comment"># Directory to scan</span>
include_globs = [<span class="val">"**/*.md"</span>, <span class="val">"**/*.rs"</span>]  <span class="comment"># Files to include</span>
exclude_globs = [<span class="val">"**/target/**"</span>]       <span class="comment"># Files to exclude</span>
follow_symlinks = <span class="val">false</span>               <span class="comment"># Follow symbolic links</span></code></pre>

<p>Each file becomes a <code>Document</code> with its content as the body, filesystem path as the source ID, and file modification time as the timestamp.</p>
</section>

<!-- Git -->
<section class="section" id="connector-git">
<h3>Git Connector</h3>

<p>Clone and index any Git repository — local or remote. Extracts per-file commit metadata (author, timestamp, SHA) and auto-generates web URLs for GitHub/GitLab repos.</p>

<pre><code><span class="key">[connectors.git]</span>
url = <span class="val">"https://github.com/acme/platform.git"</span>   <span class="comment"># Repo URL or local path</span>
branch = <span class="val">"main"</span>                               <span class="comment"># Branch to track</span>
root = <span class="val">"docs/"</span>                                 <span class="comment"># Subdirectory to scope</span>
include_globs = [<span class="val">"**/*.md"</span>, <span class="val">"**/*.rst"</span>]       <span class="comment"># File patterns</span>
shallow = <span class="val">true</span>                                  <span class="comment"># --depth 1 clone</span>
<span class="comment"># cache_dir = "./data/.git-cache/platform"     # Optional clone cache</span></code></pre>

<p>Features:</p>
<ul>
    <li>Clones on first sync, pulls on subsequent syncs</li>
    <li>Per-file last commit timestamp and author from <code>git log</code></li>
    <li>GitHub/GitLab web URLs auto-generated for each file</li>
    <li>Shallow clone support to minimize disk usage</li>
    <li>Incremental sync via checkpoint timestamps</li>
</ul>
</section>

<!-- S3 -->
<section class="section" id="connector-s3">
<h3>S3 Connector</h3>

<p>Index documents from Amazon S3 buckets (or S3-compatible services like MinIO and LocalStack).</p>

<pre><code><span class="key">[connectors.s3]</span>
bucket = <span class="val">"acme-docs"</span>                          <span class="comment"># Bucket name</span>
prefix = <span class="val">"engineering/runbooks/"</span>                <span class="comment"># Key prefix filter</span>
region = <span class="val">"us-east-1"</span>                           <span class="comment"># AWS region</span>
include_globs = [<span class="val">"**/*.md"</span>, <span class="val">"**/*.json"</span>]       <span class="comment"># Key patterns</span>
<span class="comment"># endpoint_url = "http://localhost:9000"       # For MinIO/LocalStack</span></code></pre>

<p>Requires <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables.</p>

<p>Features:</p>
<ul>
    <li>Pagination for large buckets (1000+ objects)</li>
    <li><code>LastModified</code> and <code>ETag</code> tracking for incremental sync</li>
    <li>Custom endpoint URL for S3-compatible services</li>
    <li>Glob-based include/exclude filtering on object keys</li>
</ul>
</section>

<!-- Embedding Config -->
<section class="section" id="embedding-config">
<h3>Embedding Configuration</h3>

<p>Embeddings enable semantic and hybrid search. Without embeddings, only keyword search (FTS5/BM25) is available.</p>

<pre><code><span class="key">[embedding]</span>
provider = <span class="val">"openai"</span>                  <span class="comment"># "disabled" or "openai"</span>
model = <span class="val">"text-embedding-3-small"</span>      <span class="comment"># OpenAI model name</span>
dims = <span class="val">1536</span>                           <span class="comment"># Vector dimensions</span>
batch_size = <span class="val">64</span>                       <span class="comment"># Texts per API call</span>
max_retries = <span class="val">5</span>                       <span class="comment"># Retry on failure</span>
timeout_secs = <span class="val">30</span>                     <span class="comment"># Per-request timeout</span></code></pre>

<p>Set the <code>OPENAI_API_KEY</code> environment variable before using embedding commands. Embedding is non-fatal during sync — documents are always ingested even if embedding fails.</p>
</section>

<!-- ==================== CLI REFERENCE ==================== -->
<section class="section" id="cli">
<h2>CLI Reference</h2>

<p>Every command requires <code>--config &lt;path&gt;</code> to specify the TOML configuration file.</p>

<table>
    <tr><th>Command</th><th>Description</th></tr>
    <tr><td><code>ctx init</code></td><td>Initialize database schema</td></tr>
    <tr><td><code>ctx sources</code></td><td>List available connectors and status</td></tr>
    <tr><td><code>ctx sync &lt;connector&gt;</code></td><td>Ingest data from a connector</td></tr>
    <tr><td><code>ctx search "&lt;query&gt;"</code></td><td>Search indexed documents</td></tr>
    <tr><td><code>ctx get &lt;id&gt;</code></td><td>Retrieve a document by ID</td></tr>
    <tr><td><code>ctx embed pending</code></td><td>Backfill missing embeddings</td></tr>
    <tr><td><code>ctx embed rebuild</code></td><td>Rebuild all embeddings</td></tr>
    <tr><td><code>ctx serve mcp</code></td><td>Start MCP-compatible HTTP server</td></tr>
</table>
</section>

<section class="section" id="cli-init">
<h3>ctx init</h3>
<p>Creates the SQLite database and all required tables. Idempotent — safe to run multiple times.</p>
<pre><code><span class="prompt">$</span> ctx init --config ./config/ctx.toml</code></pre>
<p>Creates: <code>documents</code>, <code>chunks</code>, <code>checkpoints</code>, <code>chunks_fts</code> (FTS5), <code>embeddings</code>, <code>chunk_vectors</code>.</p>
</section>

<section class="section" id="cli-sync">
<h3>ctx sync</h3>
<p>Ingest from a configured connector. Supports incremental sync via checkpoints.</p>
<pre><code><span class="prompt">$</span> ctx sync filesystem --config ./config/ctx.toml
<span class="prompt">$</span> ctx sync git --config ./config/ctx.toml
<span class="prompt">$</span> ctx sync s3 --config ./config/ctx.toml</code></pre>

<h4>Flags</h4>
<table>
    <tr><th>Flag</th><th>Description</th></tr>
    <tr><td><code>--full</code></td><td>Ignore checkpoint, re-ingest everything</td></tr>
    <tr><td><code>--dry-run</code></td><td>Preview without writing</td></tr>
    <tr><td><code>--since &lt;date&gt;</code></td><td>Only items after this date</td></tr>
    <tr><td><code>--until &lt;date&gt;</code></td><td>Only items before this date</td></tr>
    <tr><td><code>--limit &lt;n&gt;</code></td><td>Cap number of items to process</td></tr>
</table>
</section>

<section class="section" id="cli-search">
<h3>ctx search</h3>
<p>Search indexed documents. Returns ranked results with scores and snippets.</p>
<pre><code><span class="prompt">$</span> ctx search "authentication flow" --config ./config/ctx.toml
<span class="prompt">$</span> ctx search "deployment" --mode hybrid --config ./config/ctx.toml
<span class="prompt">$</span> ctx search "error handling" --mode semantic --limit 5 --config ./config/ctx.toml</code></pre>

<h4>Flags</h4>
<table>
    <tr><th>Flag</th><th>Description</th></tr>
    <tr><td><code>--mode keyword|semantic|hybrid</code></td><td>Search mode (default: <code>keyword</code>)</td></tr>
    <tr><td><code>--source &lt;name&gt;</code></td><td>Filter by connector source</td></tr>
    <tr><td><code>--since &lt;date&gt;</code></td><td>Filter by date</td></tr>
    <tr><td><code>--limit &lt;n&gt;</code></td><td>Max results</td></tr>
</table>

<div class="callout callout-info">
    <p><strong>Note:</strong> <code>semantic</code> and <code>hybrid</code> modes require an embedding provider to be configured and embeddings to be generated.</p>
</div>
</section>

<section class="section" id="cli-get">
<h3>ctx get</h3>
<p>Retrieve a full document by UUID, including metadata, body, and all chunks.</p>
<pre><code><span class="prompt">$</span> ctx get a1b2c3d4-e5f6-7890-abcd-ef1234567890 --config ./config/ctx.toml</code></pre>
</section>

<section class="section" id="cli-embed">
<h3>ctx embed</h3>
<p>Manage the embedding pipeline. Requires <code>[embedding].provider</code> to be set to <code>"openai"</code>.</p>

<pre><code><span class="comment"># Backfill missing or stale embeddings</span>
<span class="prompt">$</span> ctx embed pending --config ./config/ctx.toml

<span class="comment"># Delete and regenerate all embeddings</span>
<span class="prompt">$</span> ctx embed rebuild --config ./config/ctx.toml</code></pre>

<h4>Flags</h4>
<table>
    <tr><th>Flag</th><th>Description</th></tr>
    <tr><td><code>--limit &lt;n&gt;</code></td><td>Max chunks to embed (pending only)</td></tr>
    <tr><td><code>--batch-size &lt;n&gt;</code></td><td>Override config batch size</td></tr>
    <tr><td><code>--dry-run</code></td><td>Preview without embedding (pending only)</td></tr>
</table>

<p>Staleness is detected via SHA-256 hash of chunk text — if the content changed since last embed, it's re-embedded.</p>
</section>

<section class="section" id="cli-sources">
<h3>ctx sources</h3>
<p>List configured connectors and their health status.</p>
<pre><code><span class="prompt">$</span> ctx sources --config ./config/ctx.toml
<span class="comment"># filesystem  OK
# git         OK
# s3          NOT CONFIGURED</span></code></pre>
</section>

<section class="section" id="cli-serve">
<h3>ctx serve mcp</h3>
<p>Start the MCP-compatible HTTP server. Binds to the address in <code>[server].bind</code>.</p>
<pre><code><span class="prompt">$</span> ctx serve mcp --config ./config/ctx.toml
<span class="comment"># Listening on 127.0.0.1:7331</span></code></pre>
<p>CORS is enabled for cross-origin requests. See <a href="#api">HTTP API</a> for endpoint details.</p>
</section>

<!-- ==================== HTTP API ==================== -->
<section class="section" id="api">
<h2>HTTP API</h2>

<p>The MCP server exposes a JSON HTTP API. All request/response bodies are UTF-8 JSON. Timestamps are ISO 8601 (RFC 3339). IDs are lowercase UUIDs.</p>

<table>
    <tr><th>Method</th><th>Path</th><th>Description</th></tr>
    <tr><td>POST</td><td><code>/tools/search</code></td><td>Search indexed documents</td></tr>
    <tr><td>POST</td><td><code>/tools/get</code></td><td>Retrieve document by ID</td></tr>
    <tr><td>GET</td><td><code>/tools/sources</code></td><td>List connector status</td></tr>
    <tr><td>GET</td><td><code>/health</code></td><td>Health check</td></tr>
</table>
</section>

<section class="section" id="api-search">
<h3>POST /tools/search</h3>

<h4>Request</h4>
<pre><code>{
  "query": "authentication flow",
  "mode": "hybrid",
  "limit": 12,
  "filters": {
    "source": "filesystem",
    "since": "2025-01-01T00:00:00Z",
    "until": null
  }
}</code></pre>

<h4>Response</h4>
<pre><code>{
  "results": [
    {
      "id": "a1b2c3d4-...",
      "score": 0.92,
      "title": "Auth Module",
      "source": "filesystem",
      "source_id": "docs/auth.md",
      "updated_at": "2026-02-01T12:00:00Z",
      "snippet": "JWT signing key loaded from...",
      "source_url": null
    }
  ]
}</code></pre>
</section>

<section class="section" id="api-get">
<h3>POST /tools/get</h3>

<h4>Request</h4>
<pre><code>{
  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
}</code></pre>

<h4>Response</h4>
<pre><code>{
  "id": "a1b2c3d4-...",
  "source": "filesystem",
  "source_id": "docs/auth.md",
  "source_url": null,
  "title": "Auth Module",
  "author": null,
  "created_at": "2026-01-15T10:00:00Z",
  "updated_at": "2026-02-01T12:00:00Z",
  "content_type": "text/markdown",
  "body": "# Auth Module\n\n...",
  "metadata": {},
  "chunks": [
    { "index": 0, "text": "# Auth Module..." },
    { "index": 1, "text": "## JWT Signing..." }
  ]
}</code></pre>
</section>

<section class="section" id="api-sources">
<h3>GET /tools/sources</h3>

<h4>Response</h4>
<pre><code>{
  "sources": [
    { "name": "filesystem", "configured": true, "healthy": true, "notes": null },
    { "name": "git", "configured": true, "healthy": true, "notes": null },
    { "name": "s3", "configured": false, "healthy": false, "notes": "not configured" }
  ]
}</code></pre>
</section>

<section class="section" id="api-errors">
<h3>Error Handling</h3>

<p>All errors follow a consistent JSON format:</p>

<pre><code>{
  "error": {
    "code": "not_found",
    "message": "document not found: a1b2c3d4-..."
  }
}</code></pre>

<table>
    <tr><th>Code</th><th>HTTP Status</th><th>Meaning</th></tr>
    <tr><td><code>bad_request</code></td><td>400</td><td>Malformed JSON or missing fields</td></tr>
    <tr><td><code>not_found</code></td><td>404</td><td>Document ID not present</td></tr>
    <tr><td><code>embeddings_disabled</code></td><td>400</td><td>Semantic/hybrid requires embeddings</td></tr>
    <tr><td><code>internal</code></td><td>500</td><td>Unexpected server error</td></tr>
</table>
</section>

<!-- ==================== SEARCH & RETRIEVAL ==================== -->
<section class="section" id="search">
<h2>Search &amp; Retrieval</h2>

<p>Context Harness supports three search modes, all returning scores normalized to [0, 1].</p>

<table>
    <tr><th>Mode</th><th>Requires Embeddings</th><th>Description</th></tr>
    <tr><td><code>keyword</code></td><td>No</td><td>SQLite FTS5 with BM25 ranking</td></tr>
    <tr><td><code>semantic</code></td><td>Yes</td><td>Cosine similarity over chunk embeddings</td></tr>
    <tr><td><code>hybrid</code></td><td>Yes</td><td>Weighted merge of keyword + semantic</td></tr>
</table>

<p>Results are grouped by document (best chunk score wins), with deterministic tie-breaking: score descending → <code>updated_at</code> descending → <code>id</code> ascending.</p>
</section>

<section class="section" id="hybrid-scoring">
<h3>Hybrid Scoring Algorithm</h3>

<p>Hybrid search merges keyword and semantic signals using a configurable alpha weight:</p>

<pre><code><span class="comment"># Per-chunk hybrid score</span>
hybrid = (1 - alpha) × keyword_norm + alpha × vector_norm

<span class="comment"># Per-document score (MAX aggregation)</span>
doc_score = max(hybrid(chunk) for chunk in document)</code></pre>

<p>Both keyword and vector scores are min-max normalized independently per query. Missing signals default to 0.0 — a document that only appears in keyword results still gets a hybrid score.</p>

<h4>Alpha tuning</h4>
<table>
    <tr><th>Value</th><th>Behavior</th></tr>
    <tr><td><code>0.0</code></td><td>Pure keyword search (FTS5/BM25)</td></tr>
    <tr><td><code>0.3</code></td><td>Keyword-heavy hybrid</td></tr>
    <tr><td><code>0.6</code></td><td>Balanced hybrid (default)</td></tr>
    <tr><td><code>0.8</code></td><td>Semantic-heavy hybrid</td></tr>
    <tr><td><code>1.0</code></td><td>Pure semantic search</td></tr>
</table>
</section>

<!-- ==================== CURSOR / MCP ==================== -->
<section class="section" id="cursor">
<h2>Cursor / MCP Integration</h2>

<p>Context Harness serves as a context provider for Cursor, Claude, and any MCP-compatible AI tool.</p>

<h3>Setup</h3>

<ol>
    <li>Install and configure <code>ctx</code> with your documentation sources</li>
    <li>Run <code>ctx init</code> and <code>ctx sync</code> to build the knowledge base</li>
    <li>Add to your MCP configuration:</li>
</ol>

<pre><code>{
  "mcpServers": {
    "context-harness": {
      "command": "ctx",
      "args": ["--config", "/absolute/path/to/ctx.toml", "serve", "mcp"]
    }
  }
}</code></pre>

<p>Cursor will start the MCP server automatically and expose three tools to the agent:</p>
<ul>
    <li><code>context.search</code> — search your indexed documents</li>
    <li><code>context.get</code> — retrieve full documents by ID</li>
    <li><code>context.sources</code> — check connector status</li>
</ul>

<h3>Multi-project setup</h3>
<p>Run separate Context Harness instances for different projects with unique database paths and server ports:</p>
<pre><code>{
  "mcpServers": {
    "project-alpha": {
      "command": "ctx",
      "args": ["--config", "/projects/alpha/ctx.toml", "serve", "mcp"]
    },
    "project-beta": {
      "command": "ctx",
      "args": ["--config", "/projects/beta/ctx.toml", "serve", "mcp"]
    }
  }
}</code></pre>

<h3>Recommended config for Cursor</h3>
<pre><code><span class="key">[chunking]</span>
max_tokens = <span class="val">500</span>        <span class="comment"># Smaller chunks = more precise retrieval</span>

<span class="key">[retrieval]</span>
hybrid_alpha = <span class="val">0.6</span>      <span class="comment"># Balance keyword + semantic</span>
final_limit = <span class="val">8</span>          <span class="comment"># Don't overwhelm the context window</span>

<span class="key">[connectors.filesystem]</span>
root = <span class="val">"./"</span>
include_globs = [<span class="val">"**/*.md"</span>, <span class="val">"**/*.rs"</span>, <span class="val">"**/*.ts"</span>, <span class="val">"**/*.py"</span>]
exclude_globs = [<span class="val">"**/target/**"</span>, <span class="val">"**/node_modules/**"</span>, <span class="val">"**/.git/**"</span>]</code></pre>
</section>

<!-- ==================== CI/CD ==================== -->
<section class="section" id="ci-cd">
<h2>CI/CD Integration</h2>

<p>Context Harness is designed for CI pipelines. Build the knowledge base in CI, deploy the SQLite database as an artifact, and serve it wherever you need it.</p>

<h3>GitHub Actions example</h3>
<pre><code>name: Build Knowledge Base
on:
  push:
    branches: [main]
    paths: ['docs/**', 'src/**']

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Build ctx
        run: cargo build --release

      - name: Build knowledge base
        run: |
          ./target/release/ctx init --config ./config/ctx.toml
          ./target/release/ctx sync filesystem --config ./config/ctx.toml

      - name: Upload database
        uses: actions/upload-artifact@v4
        with:
          name: knowledge-base
          path: data/ctx.sqlite</code></pre>

<h3>Cron-based sync</h3>
<pre><code><span class="comment"># Re-sync every 15 minutes</span>
*/15 * * * * /opt/ctx sync filesystem --config /opt/ctx.toml >> /var/log/ctx-sync.log 2>&1</code></pre>
</section>

<!-- ==================== DEPLOYMENT ==================== -->
<section class="section" id="deployment">
<h2>Deployment</h2>

<p>Context Harness compiles to a single static binary with embedded SQLite. Deploy by copying the binary and a config file.</p>
</section>

<section class="section" id="deploy-binary">
<h3>Single Binary</h3>
<pre><code><span class="prompt">$</span> cargo build --release
<span class="prompt">$</span> scp target/release/ctx server:/opt/ctx/
<span class="prompt">$</span> scp config/ctx.toml server:/opt/ctx/

<span class="comment"># On the server</span>
<span class="prompt">$</span> /opt/ctx/ctx init --config /opt/ctx/ctx.toml
<span class="prompt">$</span> /opt/ctx/ctx sync filesystem --config /opt/ctx/ctx.toml
<span class="prompt">$</span> /opt/ctx/ctx serve mcp --config /opt/ctx/ctx.toml</code></pre>
</section>

<section class="section" id="deploy-docker">
<h3>Docker</h3>
<pre><code>FROM rust:1.82-slim AS builder
WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src/ src/
RUN cargo build --release

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y git ca-certificates \
    && rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/target/release/ctx /usr/local/bin/ctx
WORKDIR /data
COPY config/ctx.example.toml /etc/ctx/ctx.toml
EXPOSE 7331
ENTRYPOINT ["ctx"]
CMD ["serve", "mcp", "--config", "/etc/ctx/ctx.toml"]</code></pre>

<pre><code><span class="prompt">$</span> docker build -t context-harness .
<span class="prompt">$</span> docker run --rm -v ctx-data:/data context-harness init --config /etc/ctx/ctx.toml
<span class="prompt">$</span> docker run --rm -v ctx-data:/data context-harness sync filesystem --config /etc/ctx/ctx.toml
<span class="prompt">$</span> docker run -d --name ctx -p 7331:7331 -v ctx-data:/data context-harness</code></pre>
</section>

<section class="section" id="deploy-systemd">
<h3>Systemd Service</h3>
<pre><code>[Unit]
Description=Context Harness MCP Server
After=network.target

[Service]
Type=simple
ExecStart=/opt/ctx/ctx serve mcp --config /opt/ctx/ctx.toml
Environment=OPENAI_API_KEY=sk-...
Restart=on-failure
RestartSec=5
User=ctx
WorkingDirectory=/opt/ctx

[Install]
WantedBy=multi-user.target</code></pre>

<pre><code><span class="prompt">$</span> sudo systemctl enable context-harness
<span class="prompt">$</span> sudo systemctl start context-harness</code></pre>
</section>

<!-- ==================== ARCHITECTURE ==================== -->
<section class="section" id="architecture">
<h2>Architecture</h2>

<h3>Data flow</h3>
<pre><code>Connector → SourceItem → normalize() → Document → chunk() → Chunks
                                          ↓                     ↓
                                   upsert_document()     replace_chunks()
                                                               ↓
                                                         embed() → vectors
                                                               ↓
                                                     SQLite (FTS5 + sqlite-vec)
                                                               ↓
                                                     Query Engine (keyword / semantic / hybrid)
                                                               ↓
                                                     CLI  ·  MCP Server</code></pre>

<h3>Module map</h3>
<table>
    <tr><th>Module</th><th>Responsibility</th></tr>
    <tr><td><code>models.rs</code></td><td>Document, Chunk, SourceItem structs</td></tr>
    <tr><td><code>config.rs</code></td><td>TOML configuration parsing</td></tr>
    <tr><td><code>connector_fs.rs</code></td><td>Filesystem connector</td></tr>
    <tr><td><code>connector_git.rs</code></td><td>Git repository connector</td></tr>
    <tr><td><code>connector_s3.rs</code></td><td>S3 bucket connector</td></tr>
    <tr><td><code>chunk.rs</code></td><td>Paragraph-boundary text chunker</td></tr>
    <tr><td><code>ingest.rs</code></td><td>Ingestion pipeline orchestration</td></tr>
    <tr><td><code>db.rs</code></td><td>SQLite connection (WAL mode)</td></tr>
    <tr><td><code>migrate.rs</code></td><td>Schema migrations</td></tr>
    <tr><td><code>embedding.rs</code></td><td>EmbeddingProvider trait + OpenAI implementation</td></tr>
    <tr><td><code>embed_cmd.rs</code></td><td>embed pending / embed rebuild commands</td></tr>
    <tr><td><code>search.rs</code></td><td>Keyword, semantic, hybrid search</td></tr>
    <tr><td><code>get.rs</code></td><td>Document retrieval by ID</td></tr>
    <tr><td><code>sources.rs</code></td><td>Connector health listing</td></tr>
    <tr><td><code>server.rs</code></td><td>Axum HTTP server (MCP-compatible)</td></tr>
    <tr><td><code>main.rs</code></td><td>CLI entrypoint (clap)</td></tr>
</table>

<p>Full API documentation is available in the <a href="../api/context_harness/">Rustdoc API Reference</a>.</p>
</section>

<!-- ==================== ENV VARS ==================== -->
<section class="section" id="env-vars">
<h2>Environment Variables</h2>

<table>
    <tr><th>Variable</th><th>Required For</th><th>Description</th></tr>
    <tr><td><code>OPENAI_API_KEY</code></td><td>Embeddings</td><td>OpenAI API key for embedding generation</td></tr>
    <tr><td><code>AWS_ACCESS_KEY_ID</code></td><td>S3 connector</td><td>AWS access key</td></tr>
    <tr><td><code>AWS_SECRET_ACCESS_KEY</code></td><td>S3 connector</td><td>AWS secret key</td></tr>
    <tr><td><code>AWS_SESSION_TOKEN</code></td><td>S3 connector</td><td>AWS session token (optional, temporary credentials)</td></tr>
</table>
</section>

<!-- ==================== CONTRIBUTING ==================== -->
<section class="section" id="contributing">
<h2>Contributing</h2>

<pre><code><span class="prompt">$</span> git clone https://github.com/parallax-labs/context-harness.git
<span class="prompt">$</span> cd context-harness
<span class="prompt">$</span> cp config/ctx.example.toml config/ctx.toml
<span class="prompt">$</span> cargo build
<span class="prompt">$</span> cargo test</code></pre>

<p>Before submitting a PR:</p>
<ul>
    <li>Run <code>cargo fmt</code> and <code>cargo clippy</code></li>
    <li>All tests must pass (<code>cargo test</code>)</li>
    <li>Keep functions focused and well-documented</li>
</ul>

<p>See <a href="https://github.com/parallax-labs/context-harness/blob/main/CONTRIBUTING.md">CONTRIBUTING.md</a> for the full guide.</p>
</section>

</main>
</div>

<script src="../ctx-search.js" data-json="data.json" data-trigger="#search-trigger" data-placeholder="Search docs, source code, guides…"></script>

<script>
// Sidebar active link tracking
const sections = document.querySelectorAll('.section');
const navLinks = document.querySelectorAll('.nav-link');

const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            navLinks.forEach(l => l.classList.remove('active'));
            const id = entry.target.id;
            const link = document.querySelector(`.nav-link[href="#${id}"]`);
            if (link) link.classList.add('active');
        }
    });
}, { rootMargin: '-80px 0px -70% 0px', threshold: 0 });

sections.forEach(s => observer.observe(s));

// Close sidebar on link click (mobile)
navLinks.forEach(link => {
    link.addEventListener('click', () => {
        document.getElementById('sidebar').classList.remove('open');
    });
});
</script>

</body>
</html>
