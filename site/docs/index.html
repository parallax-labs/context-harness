<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Context Harness ‚Äî Documentation</title>
<meta name="description" content="Search and chat with Context Harness documentation ‚Äî guides, API reference, and architecture. Dogfooded with the Git connector and indexed by Context Harness itself.">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ö°</text></svg>">
<style>
:root {
  --bg: #0a0e17;
  --surface: #111827;
  --surface-2: #1a2332;
  --surface-3: #0f1a2a;
  --border: #1e2d3d;
  --text: #e2e8f0;
  --text-dim: #8892a4;
  --text-muted: #5a6478;
  --accent: #3b82f6;
  --accent-glow: rgba(59, 130, 246, 0.12);
  --green: #22c55e;
  --yellow: #eab308;
  --orange: #f97316;
  --purple: #a855f7;
  --teal: #14b8a6;
  --red: #ef4444;
  --radius: 12px;
  --mono: 'SF Mono', 'Fira Code', 'JetBrains Mono', monospace;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  line-height: 1.6;
}

/* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
header {
  border-bottom: 1px solid var(--border);
  padding: 14px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--surface);
  position: sticky;
  top: 0;
  z-index: 100;
}

.logo { display: flex; align-items: center; gap: 12px; font-weight: 700; font-size: 18px; text-decoration: none; color: var(--text); }
.logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--accent), var(--purple)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 16px; }

.header-right { display: flex; align-items: center; gap: 16px; }
.header-link { color: var(--text-dim); text-decoration: none; font-size: 14px; }
.header-link:hover { color: var(--accent); }

/* ‚îÄ‚îÄ Layout ‚îÄ‚îÄ */
.layout {
  display: grid;
  grid-template-columns: 260px 1fr;
  min-height: calc(100vh - 53px);
}

/* ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ */
.sidebar {
  border-right: 1px solid var(--border);
  background: var(--surface);
  padding: 20px 0;
  overflow-y: auto;
  position: sticky;
  top: 53px;
  height: calc(100vh - 53px);
}

.sidebar-section { padding: 0 16px; margin-bottom: 20px; }
.sidebar-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); margin-bottom: 8px; padding: 0 8px; }
.sidebar-link {
  display: flex; align-items: center; gap: 8px;
  padding: 6px 12px; border-radius: 6px;
  color: var(--text-dim); font-size: 13px; text-decoration: none;
  cursor: pointer; transition: all 0.15s;
}
.sidebar-link:hover { background: var(--surface-2); color: var(--text); }
.sidebar-link.active { background: var(--accent-glow); color: var(--accent); font-weight: 600; }

.sidebar-badge {
  margin-left: auto; font-size: 11px; padding: 1px 6px;
  border-radius: 10px; background: var(--surface-2); color: var(--text-muted);
  font-family: var(--mono);
}

.sidebar-divider { height: 1px; background: var(--border); margin: 12px 16px; }

/* ‚îÄ‚îÄ Main ‚îÄ‚îÄ */
.main { padding: 32px 40px; max-width: 900px; }

/* ‚îÄ‚îÄ Search ‚îÄ‚îÄ */
.search-container {
  position: relative; margin-bottom: 24px;
}
.search-input {
  width: 100%; padding: 14px 16px 14px 44px;
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); color: var(--text);
  font-size: 15px; font-family: inherit; outline: none;
  transition: border 0.2s, box-shadow 0.2s;
}
.search-input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow); }
.search-input::placeholder { color: var(--text-muted); }
.search-icon {
  position: absolute; left: 14px; top: 50%; transform: translateY(-50%);
  color: var(--text-muted); font-size: 18px; pointer-events: none;
}

.search-meta {
  display: flex; align-items: center; gap: 16px; margin-bottom: 16px;
  font-size: 13px; color: var(--text-dim);
}

.mode-pills { display: flex; gap: 4px; background: var(--surface); border-radius: 8px; padding: 3px; border: 1px solid var(--border); }
.mode-pill {
  padding: 5px 14px; border-radius: 6px; border: none;
  background: transparent; color: var(--text-dim);
  font-size: 12px; cursor: pointer; font-family: inherit; font-weight: 500;
  transition: all 0.2s;
}
.mode-pill:hover { color: var(--text); }
.mode-pill.active { background: var(--accent); color: white; }
.mode-pill[data-mode="chat"].active { background: var(--purple); }

.filter-pills { display: flex; gap: 4px; margin-left: auto; }
.filter-pill {
  padding: 4px 12px; border-radius: 14px; border: 1px solid var(--border);
  background: transparent; color: var(--text-dim);
  font-size: 12px; cursor: pointer; font-family: inherit;
  transition: all 0.2s;
}
.filter-pill:hover { border-color: var(--accent); color: var(--text); }
.filter-pill.active { border-color: var(--accent); background: var(--accent-glow); color: var(--accent); }

/* ‚îÄ‚îÄ Results ‚îÄ‚îÄ */
.result-count { font-size: 13px; color: var(--text-dim); margin-bottom: 16px; }

.result-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px;
  margin-bottom: 12px;
  cursor: pointer;
  transition: border-color 0.2s, transform 0.15s;
}
.result-card:hover { border-color: var(--accent); transform: translateY(-1px); }

.result-header {
  display: flex; align-items: flex-start; justify-content: space-between; margin-bottom: 8px;
}
.result-title { font-weight: 600; font-size: 15px; color: var(--text); }
.result-score {
  font-size: 12px; font-family: var(--mono); padding: 2px 8px;
  border-radius: 6px; font-weight: 600;
}
.score-high { background: rgba(34,197,94,0.15); color: var(--green); }
.score-mid  { background: rgba(234,179,8,0.15); color: var(--yellow); }
.score-low  { background: rgba(248,113,22,0.15); color: var(--orange); }

.result-meta {
  display: flex; gap: 12px; align-items: center; margin-bottom: 10px;
  font-size: 12px; color: var(--text-muted);
}
.result-tag {
  padding: 2px 8px; border-radius: 4px; font-size: 11px;
  font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em;
}
.tag-guide { background: rgba(59,130,246,0.15); color: var(--accent); }
.tag-api { background: rgba(168,85,247,0.15); color: var(--purple); }
.tag-meta { background: rgba(20,184,166,0.15); color: var(--teal); }

.result-snippet {
  font-size: 13px; line-height: 1.7; color: var(--text-dim);
  white-space: pre-wrap; font-family: var(--mono);
  max-height: 120px; overflow: hidden;
}
.result-snippet mark { background: var(--accent-glow); color: var(--accent); border-radius: 2px; padding: 0 2px; }

.result-source { font-size: 12px; color: var(--text-muted); margin-top: 8px; }
.result-source a { color: var(--accent); }

/* ‚îÄ‚îÄ Document View ‚îÄ‚îÄ */
.doc-view { display: none; }
.doc-view.active { display: block; }
.doc-back { color: var(--accent); font-size: 13px; text-decoration: none; cursor: pointer; display: inline-flex; align-items: center; gap: 6px; margin-bottom: 16px; }
.doc-back:hover { text-decoration: underline; }
.doc-title { font-size: 24px; font-weight: 700; margin-bottom: 8px; }
.doc-meta-bar { display: flex; gap: 12px; margin-bottom: 20px; font-size: 13px; color: var(--text-dim); }
.doc-body {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 24px;
  white-space: pre-wrap; font-family: var(--mono); font-size: 13px;
  line-height: 1.8; max-height: 70vh; overflow-y: auto;
}

/* ‚îÄ‚îÄ Welcome ‚îÄ‚îÄ */
.welcome { text-align: center; padding: 80px 24px; }
.welcome-title { font-size: 28px; font-weight: 700; margin-bottom: 12px; }
.welcome-sub { font-size: 15px; color: var(--text-dim); max-width: 500px; margin: 0 auto 24px; }
.welcome-badge {
  display: inline-flex; align-items: center; gap: 8px;
  padding: 6px 16px; border-radius: 20px;
  background: var(--surface); border: 1px solid var(--border);
  font-size: 12px; color: var(--text-dim); font-family: var(--mono);
}
.welcome-badge .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--green); }

/* ‚îÄ‚îÄ Loading ‚îÄ‚îÄ */
.loading-spinner {
  width: 32px; height: 32px; border: 3px solid var(--border);
  border-top-color: var(--accent); border-radius: 50%;
  animation: spin 0.8s linear infinite; margin: 40px auto;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* ‚îÄ‚îÄ Model Progress ‚îÄ‚îÄ */
.model-progress {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 16px; margin-bottom: 16px;
  display: none;
}
.model-progress.visible { display: block; }
.prog-bar { height: 4px; background: var(--surface-2); border-radius: 4px; overflow: hidden; margin-top: 8px; }
.prog-fill { height: 100%; background: var(--accent); transition: width 0.3s; width: 0; }
.prog-text { font-size: 12px; color: var(--text-dim); display: flex; justify-content: space-between; margin-top: 6px; }

/* ‚îÄ‚îÄ Empty ‚îÄ‚îÄ */
.empty-state { text-align: center; padding: 60px 24px; color: var(--text-dim); font-size: 14px; }

/* ============================
   Chat UI Styles
   ============================ */

.chat-container {
  display: none;
  flex-direction: column;
  height: calc(100vh - 53px - 64px);
  max-height: calc(100vh - 53px - 64px);
}
.chat-container.active { display: flex; }

/* Chat header bar */
.chat-header {
  display: flex; align-items: center; justify-content: space-between;
  padding-bottom: 16px; border-bottom: 1px solid var(--border); margin-bottom: 0;
  flex-shrink: 0;
}
.chat-header-left { display: flex; align-items: center; gap: 12px; }
.chat-header-title { font-size: 16px; font-weight: 600; }
.chat-backend-badge {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 3px 10px; border-radius: 12px;
  background: var(--surface-2); border: 1px solid var(--border);
  font-size: 11px; color: var(--text-dim); font-family: var(--mono);
}
.chat-backend-badge .bdot {
  width: 6px; height: 6px; border-radius: 50%;
}
.bdot-ready { background: var(--green); }
.bdot-loading { background: var(--yellow); animation: pulse-dot 1s infinite; }
.bdot-off { background: var(--text-muted); }
@keyframes pulse-dot { 0%,100%{opacity:1} 50%{opacity:0.4} }

.chat-actions { display: flex; align-items: center; gap: 8px; }
.chat-btn {
  padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border);
  background: transparent; color: var(--text-dim); font-size: 12px;
  cursor: pointer; font-family: inherit; transition: all 0.2s;
}
.chat-btn:hover { border-color: var(--accent); color: var(--text); }

/* Settings dropdown */
.settings-wrapper { position: relative; }
.settings-dropdown {
  display: none; position: absolute; top: calc(100% + 8px); right: 0;
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 16px; width: 320px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4); z-index: 200;
}
.settings-dropdown.open { display: block; }
.settings-label { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-muted); margin-bottom: 8px; }
.settings-radio-group { display: flex; flex-direction: column; gap: 6px; margin-bottom: 16px; }
.settings-radio {
  display: flex; align-items: center; gap: 10px; padding: 8px 12px;
  border-radius: 8px; border: 1px solid var(--border);
  cursor: pointer; transition: all 0.15s;
}
.settings-radio:hover { border-color: var(--accent); }
.settings-radio.selected { border-color: var(--accent); background: var(--accent-glow); }
.settings-radio input { display: none; }
.settings-radio-dot {
  width: 14px; height: 14px; border-radius: 50%; border: 2px solid var(--border);
  display: flex; align-items: center; justify-content: center; flex-shrink: 0;
}
.settings-radio.selected .settings-radio-dot { border-color: var(--accent); }
.settings-radio.selected .settings-radio-dot::after {
  content: ''; width: 6px; height: 6px; border-radius: 50%; background: var(--accent);
}
.settings-radio-info { flex: 1; }
.settings-radio-name { font-size: 13px; font-weight: 600; }
.settings-radio-desc { font-size: 11px; color: var(--text-dim); }

.settings-apikey-row { display: none; margin-bottom: 8px; }
.settings-apikey-row.visible { display: block; }
.settings-apikey-input {
  width: 100%; padding: 8px 12px; background: var(--surface-2);
  border: 1px solid var(--border); border-radius: 6px;
  color: var(--text); font-size: 13px; font-family: var(--mono);
  outline: none;
}
.settings-apikey-input:focus { border-color: var(--accent); }
.settings-hint { font-size: 11px; color: var(--text-muted); margin-top: 4px; }

/* Messages area */
.chat-messages {
  flex: 1; overflow-y: auto; padding: 20px 0;
  display: flex; flex-direction: column; gap: 16px;
}

.chat-msg {
  display: flex; gap: 12px; max-width: 100%;
}
.chat-msg-user { justify-content: flex-end; }
.chat-msg-assistant { justify-content: flex-start; }

.chat-avatar {
  width: 28px; height: 28px; border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  font-size: 14px; flex-shrink: 0;
}
.avatar-user { background: var(--accent); color: white; }
.avatar-assistant { background: linear-gradient(135deg, var(--purple), var(--accent)); color: white; }

.chat-bubble {
  padding: 12px 16px; border-radius: 12px; max-width: 85%;
  font-size: 14px; line-height: 1.7;
}
.bubble-user {
  background: var(--accent); color: white;
  border-bottom-right-radius: 4px;
}
.bubble-assistant {
  background: var(--surface); border: 1px solid var(--border);
  border-bottom-left-radius: 4px;
}

/* Markdown in assistant bubbles */
.bubble-assistant h1, .bubble-assistant h2, .bubble-assistant h3 {
  font-size: 15px; font-weight: 700; margin: 12px 0 4px 0; color: var(--text);
}
.bubble-assistant h1 { font-size: 17px; }
.bubble-assistant p { margin: 6px 0; }
.bubble-assistant ul, .bubble-assistant ol { margin: 6px 0 6px 20px; }
.bubble-assistant li { margin: 2px 0; }
.bubble-assistant code {
  background: var(--surface-2); padding: 1px 5px; border-radius: 4px;
  font-family: var(--mono); font-size: 12px; color: var(--accent);
}
.bubble-assistant pre {
  background: var(--surface-3); border: 1px solid var(--border);
  border-radius: 8px; padding: 12px; margin: 8px 0;
  overflow-x: auto; font-family: var(--mono); font-size: 12px;
  line-height: 1.5;
}
.bubble-assistant pre code {
  background: none; padding: 0; color: var(--text);
}
.bubble-assistant strong { color: var(--text); }
.bubble-assistant a { color: var(--accent); }
.bubble-assistant blockquote {
  border-left: 3px solid var(--accent); padding-left: 12px;
  margin: 8px 0; color: var(--text-dim);
}

/* Sources footer */
.chat-sources {
  margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border);
  font-size: 12px; color: var(--text-muted);
}
.chat-sources-title { font-weight: 600; margin-bottom: 4px; }
.chat-source-link {
  display: inline-block; margin-right: 8px; margin-bottom: 4px;
  padding: 2px 8px; border-radius: 4px; background: var(--surface-2);
  color: var(--accent); cursor: pointer; font-size: 11px;
  text-decoration: none; transition: background 0.15s;
}
.chat-source-link:hover { background: var(--accent-glow); }

/* Typing indicator */
.typing-indicator {
  display: flex; gap: 4px; padding: 8px 0;
}
.typing-indicator span {
  width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted);
  animation: typing-bounce 1.4s infinite;
}
.typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
.typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
@keyframes typing-bounce {
  0%,60%,100% { transform: translateY(0); opacity: 0.4; }
  30% { transform: translateY(-6px); opacity: 1; }
}

/* Chat welcome */
.chat-welcome { text-align: center; padding: 40px 24px; }
.chat-welcome-title { font-size: 22px; font-weight: 700; margin-bottom: 8px; }
.chat-welcome-sub { font-size: 14px; color: var(--text-dim); max-width: 460px; margin: 0 auto 20px; }
.chat-suggestions {
  display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: 16px;
}
.chat-suggestion {
  padding: 8px 16px; border-radius: 20px; border: 1px solid var(--border);
  background: var(--surface); color: var(--text-dim); font-size: 13px;
  cursor: pointer; transition: all 0.2s; font-family: inherit;
}
.chat-suggestion:hover { border-color: var(--accent); color: var(--text); }

/* Chat input bar */
.chat-input-bar {
  display: flex; gap: 8px; padding-top: 16px; border-top: 1px solid var(--border);
  flex-shrink: 0; align-items: flex-end;
}
.chat-input {
  flex: 1; padding: 12px 16px; background: var(--surface);
  border: 1px solid var(--border); border-radius: var(--radius);
  color: var(--text); font-size: 14px; font-family: inherit;
  outline: none; resize: none; min-height: 44px; max-height: 120px;
  transition: border 0.2s;
}
.chat-input:focus { border-color: var(--accent); }
.chat-input::placeholder { color: var(--text-muted); }
.chat-send {
  padding: 12px 20px; border-radius: var(--radius); border: none;
  background: var(--purple); color: white; font-size: 14px;
  cursor: pointer; font-family: inherit; font-weight: 600;
  transition: opacity 0.2s; height: 44px;
}
.chat-send:hover { opacity: 0.9; }
.chat-send:disabled { opacity: 0.4; cursor: not-allowed; }

/* LLM progress bar (in chat) */
.chat-llm-progress {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 12px 16px; margin-bottom: 12px;
  display: none; flex-shrink: 0;
}
.chat-llm-progress.visible { display: block; }

/* ‚îÄ‚îÄ Tool Call Cards ‚îÄ‚îÄ */
.tool-call-card {
  background: var(--surface-3);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 10px 14px;
  margin: 8px 0;
  font-size: 12px;
  transition: border-color 0.2s;
}
.tool-call-card:hover { border-color: rgba(20,184,166,0.4); }

.tool-call-header {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  user-select: none;
}
.tool-call-icon { font-size: 14px; flex-shrink: 0; }
.tool-call-name {
  font-weight: 600;
  color: var(--teal);
  font-family: var(--mono);
  font-size: 12px;
  flex-shrink: 0;
}
.tool-call-args {
  color: var(--text-dim);
  font-family: var(--mono);
  font-size: 11px;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.tool-call-status {
  font-size: 11px;
  color: var(--text-muted);
  flex-shrink: 0;
  font-family: var(--mono);
}
.tool-call-status.success { color: var(--green); }
.tool-call-status.error { color: var(--red); }

.tool-call-detail {
  display: none;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--border);
  max-height: 200px;
  overflow-y: auto;
  font-family: var(--mono);
  font-size: 11px;
  line-height: 1.5;
  color: var(--text-dim);
  white-space: pre-wrap;
  word-break: break-word;
}
.tool-call-detail.open { display: block; }

.tool-thinking {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 0;
  font-size: 13px;
  color: var(--text-dim);
}
.tool-thinking-spinner {
  width: 14px; height: 14px;
  border: 2px solid var(--border);
  border-top-color: var(--teal);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

.agent-divider {
  height: 1px;
  background: var(--border);
  margin: 12px 0;
}

.settings-divider-line {
  height: 1px;
  background: var(--border);
  margin: 12px 0;
}

.tool-badge {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.04em;
}
.tool-badge-search { background: rgba(20,184,166,0.15); color: var(--teal); }
.tool-badge-get { background: rgba(168,85,247,0.15); color: var(--purple); }
.tool-badge-list { background: rgba(59,130,246,0.15); color: var(--accent); }

/* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
@media (max-width: 768px) {
  .layout { grid-template-columns: 1fr; }
  .sidebar { display: none; }
  .main { padding: 20px 16px; }
  .search-meta { flex-wrap: wrap; }
  .filter-pills { margin-left: 0; }
  .chat-bubble { max-width: 95%; }
  .settings-dropdown { width: 280px; right: -60px; }
}
</style>
</head>
<body>

<header>
  <a href="../" class="logo">
    <div class="logo-icon">‚ö°</div>
    <span>Context Harness <span style="font-weight:400;color:var(--text-dim)">Docs</span></span>
  </a>
  <div class="header-right">
    <a href="../demo/" class="header-link">Live Demo</a>
    <a href="../api/context_harness/" class="header-link">API Reference</a>
    <a href="https://github.com/parallax-labs/context-harness" class="header-link" target="_blank" rel="noopener">GitHub</a>
  </div>
</header>

<div class="layout">
  <aside class="sidebar" id="sidebar">
    <div class="sidebar-section">
      <div class="sidebar-title">Guides</div>
      <div id="sidebarGuides"></div>
    </div>
    <div class="sidebar-divider"></div>
    <div class="sidebar-section">
      <div class="sidebar-title">Reference</div>
      <div id="sidebarRef"></div>
    </div>
    <div class="sidebar-divider"></div>
    <div class="sidebar-section">
      <div class="sidebar-title">Source Modules</div>
      <div id="sidebarModules"></div>
    </div>
    <div class="sidebar-divider"></div>
    <div class="sidebar-section">
      <a href="../api/context_harness/" class="sidebar-link" target="_blank" rel="noopener">
        üìñ Full Rustdoc API
      </a>
    </div>
  </aside>

  <div class="main">
    <!-- Mode pills (shared between search and chat) -->
    <div class="search-meta" id="modePillsBar">
      <div class="mode-pills">
        <button class="mode-pill active" data-mode="keyword">Keyword</button>
        <button class="mode-pill" data-mode="semantic">Semantic</button>
        <button class="mode-pill" data-mode="hybrid">Hybrid</button>
        <button class="mode-pill" data-mode="chat">üí¨ Chat</button>
      </div>
    </div>

    <!-- Search page -->
    <div id="searchPage">
      <div class="search-container">
        <span class="search-icon">üîç</span>
        <input type="text" class="search-input" id="searchInput" placeholder="Search documentation‚Ä¶" autofocus>
      </div>

      <div class="search-meta">
        <div class="filter-pills">
          <button class="filter-pill active" data-filter="all">All</button>
          <button class="filter-pill" data-filter="guide">Guides</button>
          <button class="filter-pill" data-filter="api">API</button>
          <button class="filter-pill" data-filter="meta">Meta</button>
        </div>
      </div>

      <div id="modelProgress" class="model-progress">
        <span id="progDetail" style="font-size:13px;">Loading model‚Ä¶</span>
        <div class="prog-bar"><div class="prog-fill" id="progFill"></div></div>
        <div class="prog-text"><span id="progPct">0%</span></div>
      </div>

      <div id="resultCount" class="result-count"></div>
      <div id="searchResults"></div>

      <div id="welcomeState" class="welcome">
        <div class="welcome-title">Documentation Search</div>
        <div class="welcome-sub">
          Search across guides, API reference, and source code.
          This page is indexed by Context Harness itself ‚Äî dogfooding the Git connector.
        </div>
        <div class="welcome-badge">
          <span class="dot"></span>
          <span id="docStats">Loading‚Ä¶</span>
        </div>
      </div>
    </div>

    <!-- Chat page -->
    <div class="chat-container" id="chatPage">
      <div class="chat-header">
        <div class="chat-header-left">
          <span class="chat-header-title">Chat with Docs</span>
          <span class="chat-backend-badge" id="chatBackendBadge">
            <span class="bdot bdot-off" id="chatBdot"></span>
            <span id="chatBackendLabel">No backend</span>
          </span>
        </div>
        <div class="chat-actions">
          <button class="chat-btn" onclick="clearChat()">New Chat</button>
          <div class="settings-wrapper">
            <button class="chat-btn" id="settingsBtn">‚öô Settings</button>
            <div class="settings-dropdown" id="settingsDropdown">
              <div class="settings-label">Inference Backend</div>
              <div class="settings-radio-group">
                <label class="settings-radio selected" id="radioWebllm" onclick="selectBackend('webllm')">
                  <input type="radio" name="backend" value="webllm" checked>
                  <div class="settings-radio-dot"></div>
                  <div class="settings-radio-info">
                    <div class="settings-radio-name">üñ• WebLLM (Offline)</div>
                    <div class="settings-radio-desc">Runs Qwen3-4B in your browser via WebGPU. ~2.5GB download, cached for future visits. No API key needed.</div>
                  </div>
                </label>
                <label class="settings-radio" id="radioOpenai" onclick="selectBackend('openai')">
                  <input type="radio" name="backend" value="openai">
                  <div class="settings-radio-dot"></div>
                  <div class="settings-radio-info">
                    <div class="settings-radio-name">üîë OpenAI API</div>
                    <div class="settings-radio-desc">Uses gpt-4o-mini via your own API key. Key stays in your browser, never sent to our servers.</div>
                  </div>
                </label>
              </div>
              <div class="settings-apikey-row" id="apikeyRow">
                <div class="settings-label">OpenAI API Key</div>
                <input type="password" class="settings-apikey-input" id="apikeyInput" placeholder="sk-‚Ä¶">
                <div class="settings-hint">Stored in localStorage. Never leaves your browser.</div>
              </div>
              <div class="settings-divider-line"></div>
              <div class="settings-label">Tool Execution</div>
              <div class="settings-radio-group">
                <label class="settings-radio selected" id="radioLocal" onclick="selectToolMode('local')">
                  <input type="radio" name="toolmode" value="local" checked>
                  <div class="settings-radio-dot"></div>
                  <div class="settings-radio-info">
                    <div class="settings-radio-name">üì¶ Browser (Offline)</div>
                    <div class="settings-radio-desc">Agent tools run client-side using pre-indexed data. No server needed.</div>
                  </div>
                </label>
                <label class="settings-radio" id="radioMcp" onclick="selectToolMode('mcp')">
                  <input type="radio" name="toolmode" value="mcp">
                  <div class="settings-radio-dot"></div>
                  <div class="settings-radio-info">
                    <div class="settings-radio-name">üîå MCP Server</div>
                    <div class="settings-radio-desc">Connect to a running <code style="font-size:11px">ctx serve mcp</code> for live data.</div>
                  </div>
                </label>
              </div>
              <div class="settings-apikey-row" id="mcpUrlRow">
                <div class="settings-label">MCP Server URL</div>
                <input type="text" class="settings-apikey-input" id="mcpUrlInput" placeholder="http://localhost:3636" value="http://localhost:3636">
                <div class="settings-hint" id="mcpStatus">Not connected ‚Äî start <code style="font-size:10px">ctx serve mcp</code> locally</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="chatLlmProgress" class="chat-llm-progress">
        <span id="chatProgDetail" style="font-size:13px;">Loading LLM‚Ä¶</span>
        <div class="prog-bar"><div class="prog-fill" id="chatProgFill"></div></div>
        <div class="prog-text"><span id="chatProgPct">0%</span></div>
      </div>

      <div class="chat-messages" id="chatMessages">
        <div class="chat-welcome" id="chatWelcome">
          <div class="chat-welcome-title">Agent-Powered Documentation Chat</div>
          <div class="chat-welcome-sub">
            Ask questions and watch the agent use Context Harness MCP tools ‚Äî search, retrieve, and synthesize answers.
            The same tools available to Cursor and other AI editors, running right here in your browser.
          </div>
          <div class="chat-suggestions" id="chatSuggestions">
            <button class="chat-suggestion" onclick="askSuggestion(this)">How do I set up the Git connector?</button>
            <button class="chat-suggestion" onclick="askSuggestion(this)">What search modes are available?</button>
            <button class="chat-suggestion" onclick="askSuggestion(this)">Show me the S3 connector config</button>
            <button class="chat-suggestion" onclick="askSuggestion(this)">How does the chunking algorithm work?</button>
          </div>
        </div>
      </div>

      <div class="chat-input-bar">
        <textarea class="chat-input" id="chatInput" placeholder="Ask a question about the docs‚Ä¶" rows="1"></textarea>
        <button class="chat-send" id="chatSend" onclick="sendChatMessage()">Send</button>
      </div>
    </div>

    <!-- Document view -->
    <div id="docView" class="doc-view">
      <a class="doc-back" onclick="showSearch()">‚Üê Back to results</a>
      <h1 class="doc-title" id="docTitle"></h1>
      <div class="doc-meta-bar" id="docMeta"></div>
      <pre class="doc-body" id="docBody"></pre>
    </div>
  </div>
</div>

<script>
/* ====================================================================
   Context Harness Documentation ‚Äî Client-Side Search + Chat
   Uses BM25 for keyword search, Transformers.js for semantic search,
   and WebLLM/OpenAI for RAG-powered chat.
   Data is pre-indexed in CI via the Git connector.
   ==================================================================== */

let DATA = { documents: [], chunks: [] };
let currentMode = 'keyword';
let currentFilter = 'all';

// Semantic search state
let pipeline = null;
let modelReady = false;
let modelLoading = false;
let chunkEmbeddings = [];
let _modelPromise = null;

// ‚îÄ‚îÄ Data Loading ‚îÄ‚îÄ
async function init() {
  try {
    const resp = await fetch('data.json');
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    DATA = await resp.json();
  } catch (e) {
    document.getElementById('docStats').textContent = 'data.json not found ‚Äî run scripts/build-docs.sh first';
    return;
  }

  document.getElementById('docStats').textContent =
    `${DATA.documents.length} documents ¬∑ ${DATA.chunks.length} chunks ¬∑ indexed via Git connector`;

  buildSidebar();
  buildIndex();

  // Try to load cached embeddings
  if (loadCachedEmbeddings()) {
    modelReady = true;
    _modelPromise = loadModel().catch(e => console.warn('Background model load:', e));
  }

  // Restore chat settings
  initChatSettings();
}

// ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ
function classifyDoc(sourceId) {
  if (sourceId.startsWith('docs/')) return 'guide';
  if (sourceId.startsWith('src/')) return 'api';
  return 'meta';
}

function buildSidebar() {
  const guides = [], refs = [], modules = [];

  DATA.documents.forEach(d => {
    const kind = classifyDoc(d.source_id);
    const title = d.title || d.source_id;
    const entry = { id: d.id, title, sourceId: d.source_id };
    if (kind === 'guide') guides.push(entry);
    else if (kind === 'api') modules.push(entry);
    else refs.push(entry);
  });

  const renderList = (items, container) => {
    container.innerHTML = items.map(item =>
      `<a class="sidebar-link" onclick="viewDocument('${item.id}')" title="${item.sourceId}">${item.title}</a>`
    ).join('');
  };

  renderList(guides, document.getElementById('sidebarGuides'));
  renderList(refs, document.getElementById('sidebarRef'));
  renderList(modules, document.getElementById('sidebarModules'));
}

// ‚îÄ‚îÄ BM25 Index ‚îÄ‚îÄ
let bm25Index = {};
let avgDl = 0;
const BM25_K1 = 1.2, BM25_B = 0.75;

function tokenize(text) {
  return text.toLowerCase().replace(/[^\w\s]/g, ' ').split(/\s+/).filter(t => t.length > 1);
}

function buildIndex() {
  const N = DATA.chunks.length;
  const dl = [];
  const tf = [];
  const df = {};

  DATA.chunks.forEach((chunk, i) => {
    const tokens = tokenize(chunk.text);
    dl.push(tokens.length);
    const freq = {};
    tokens.forEach(t => { freq[t] = (freq[t] || 0) + 1; });
    tf.push(freq);
    const seen = new Set(tokens);
    seen.forEach(t => { df[t] = (df[t] || 0) + 1; });
  });

  avgDl = dl.reduce((a, b) => a + b, 0) / (N || 1);
  bm25Index = { N, dl, tf, df };
}

function bm25Search(query) {
  const qTokens = tokenize(query);
  if (qTokens.length === 0) return [];

  const { N, dl, tf, df } = bm25Index;
  const scores = [];

  for (let i = 0; i < N; i++) {
    let score = 0;
    for (const qt of qTokens) {
      const tfi = tf[i][qt] || 0;
      if (tfi === 0) continue;
      const dfi = df[qt] || 0;
      const idf = Math.log((N - dfi + 0.5) / (dfi + 0.5) + 1);
      const num = tfi * (BM25_K1 + 1);
      const denom = tfi + BM25_K1 * (1 - BM25_B + BM25_B * dl[i] / avgDl);
      score += idf * num / denom;
    }
    if (score > 0) scores.push({ idx: i, score });
  }

  scores.sort((a, b) => b.score - a.score);
  return scores.slice(0, 20).map(s => chunkToResult(s.idx, s.score));
}

function chunkToResult(chunkIdx, rawScore) {
  const chunk = DATA.chunks[chunkIdx];
  const doc = DATA.documents.find(d => d.id === chunk.document_id);

  return {
    id: doc?.id || '',
    title: doc?.title || '',
    source: doc?.source || 'git',
    source_id: doc?.source_id || '',
    source_url: doc?.source_url || '',
    updated_at: doc?.updated_at || 0,
    score: Math.min(rawScore / (rawScore + 2), 1),
    snippet: chunk.text.substring(0, 300),
    chunk_index: chunk.chunk_index,
    text: chunk.text,
  };
}

// ‚îÄ‚îÄ Semantic Search ‚îÄ‚îÄ
function loadCachedEmbeddings() {
  try {
    const hash = DATA.chunks.map(c => c.id).join(',');
    if (localStorage.getItem('ctx_docs_hash') === hash) {
      const cached = JSON.parse(localStorage.getItem('ctx_docs_embeddings'));
      if (cached && cached.length === DATA.chunks.length) {
        chunkEmbeddings = cached;
        return true;
      }
    }
  } catch (e) { /* ignore */ }
  return false;
}

async function loadModel() {
  if (_modelPromise) return _modelPromise;

  _modelPromise = (async () => {
    modelLoading = true;
    const prog = document.getElementById('modelProgress');
    prog.classList.add('visible');

    try {
      const { pipeline: createPipeline, env } = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.5.1');
      env.allowLocalModels = false;

      document.getElementById('progDetail').textContent = 'Initializing model‚Ä¶';
      document.getElementById('progFill').style.width = '20%';
      document.getElementById('progPct').textContent = '20%';

      pipeline = await createPipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2', {
        progress_callback: (p) => {
          if (p.status === 'progress' && p.progress) {
            const pct = Math.round(20 + p.progress * 0.4);
            document.getElementById('progFill').style.width = pct + '%';
            document.getElementById('progPct').textContent = pct + '%';
            document.getElementById('progDetail').textContent = `Downloading model: ${p.file || ''}`;
          }
        }
      });

      document.getElementById('progDetail').textContent = `Embedding ${DATA.chunks.length} chunks‚Ä¶`;
      document.getElementById('progFill').style.width = '60%';
      document.getElementById('progPct').textContent = '60%';

      chunkEmbeddings = [];
      for (let i = 0; i < DATA.chunks.length; i++) {
        const result = await pipeline(DATA.chunks[i].text, { pooling: 'mean', normalize: true });
        chunkEmbeddings.push(Array.from(result.data));
        const pct = Math.round(60 + (i / DATA.chunks.length) * 40);
        document.getElementById('progFill').style.width = pct + '%';
        document.getElementById('progPct').textContent = pct + '%';
        document.getElementById('progDetail').textContent = `Embedding chunk ${i + 1}/${DATA.chunks.length}‚Ä¶`;
      }

      try {
        localStorage.setItem('ctx_docs_embeddings', JSON.stringify(chunkEmbeddings));
        localStorage.setItem('ctx_docs_hash', DATA.chunks.map(c => c.id).join(','));
      } catch (e) { /* storage full */ }

      modelReady = true;
      document.getElementById('progFill').style.width = '100%';
      document.getElementById('progPct').textContent = '100%';
      document.getElementById('progDetail').textContent = 'Ready!';
      setTimeout(() => prog.classList.remove('visible'), 2000);
      return true;
    } catch (e) {
      document.getElementById('progDetail').textContent = `Error: ${e.message}`;
      document.getElementById('progFill').style.background = 'var(--red)';
      modelLoading = false;
      _modelPromise = null;
      throw e;
    }
  })();

  return _modelPromise;
}

function cosineSim(a, b) {
  let dot = 0, na = 0, nb = 0;
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i];
    na += a[i] * a[i];
    nb += b[i] * b[i];
  }
  return dot / (Math.sqrt(na) * Math.sqrt(nb) + 1e-8);
}

async function semanticSearch(query) {
  const result = await pipeline(query, { pooling: 'mean', normalize: true });
  const qVec = Array.from(result.data);

  const scores = [];
  for (let i = 0; i < DATA.chunks.length; i++) {
    const sim = cosineSim(qVec, chunkEmbeddings[i]);
    if (sim > 0.1) scores.push({ idx: i, score: sim });
  }
  scores.sort((a, b) => b.score - a.score);
  return scores.slice(0, 20).map(s => chunkToResult(s.idx, s.score));
}

async function hybridSearch(query, topK = 20) {
  const kw = bm25Search(query);
  const sem = modelReady ? await semanticSearch(query) : [];

  const normalize = (arr) => {
    if (arr.length === 0) return [];
    const scores = arr.map(r => r.score);
    const min = Math.min(...scores), max = Math.max(...scores);
    const range = max - min || 1;
    return arr.map(r => ({ ...r, score: (r.score - min) / range }));
  };

  const alpha = sem.length > 0 ? 0.6 : 0;
  const kwNorm = normalize(kw);
  const semNorm = normalize(sem);
  const merged = {};

  kwNorm.forEach(r => {
    const key = r.id + ':' + r.chunk_index;
    merged[key] = { ...r, score: (1 - alpha) * r.score };
  });
  semNorm.forEach(r => {
    const key = r.id + ':' + r.chunk_index;
    if (merged[key]) merged[key].score += alpha * r.score;
    else merged[key] = { ...r, score: alpha * r.score };
  });

  return Object.values(merged).sort((a, b) => b.score - a.score).slice(0, topK);
}

// ‚îÄ‚îÄ Search Execution ‚îÄ‚îÄ
let debounceTimer;
const searchInput = document.getElementById('searchInput');

searchInput.addEventListener('input', () => {
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(doSearch, 200);
});

searchInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') { clearTimeout(debounceTimer); doSearch(); }
});

async function doSearch() {
  const query = searchInput.value.trim();
  if (!query) {
    document.getElementById('searchResults').innerHTML = '';
    document.getElementById('resultCount').textContent = '';
    document.getElementById('welcomeState').style.display = 'block';
    return;
  }

  document.getElementById('welcomeState').style.display = 'none';
  const area = document.getElementById('searchResults');
  area.innerHTML = '<div class="loading-spinner"></div>';
  document.getElementById('resultCount').textContent = 'Searching‚Ä¶';

  const start = performance.now();

  try {
    let results = [];
    if (currentMode === 'keyword') {
      results = bm25Search(query);
    } else if (currentMode === 'semantic') {
      if (!modelReady) await loadModel();
      results = await semanticSearch(query);
    } else if (currentMode === 'hybrid') {
      if (!modelReady) await loadModel();
      results = await hybridSearch(query);
    }

    // Apply filter
    if (currentFilter !== 'all') {
      results = results.filter(r => classifyDoc(r.source_id) === currentFilter);
    }

    const elapsed = (performance.now() - start).toFixed(0);
    document.getElementById('resultCount').textContent =
      `${results.length} result${results.length !== 1 ? 's' : ''} in ${elapsed}ms`;

    if (results.length === 0) {
      area.innerHTML = '<div class="empty-state">No results found. Try different terms or search mode.</div>';
      return;
    }

    area.innerHTML = results.map((r, i) => renderResult(r, query)).join('');
  } catch (e) {
    area.innerHTML = `<div class="empty-state" style="color:var(--red)">Search error: ${e.message}</div>`;
    document.getElementById('resultCount').textContent = 'Error';
    console.error('Search failed:', e);
  }
}

function renderResult(r, query) {
  const score = r.score.toFixed(2);
  const scoreClass = r.score >= 0.7 ? 'score-high' : r.score >= 0.4 ? 'score-mid' : 'score-low';
  const kind = classifyDoc(r.source_id);
  const tagClass = kind === 'guide' ? 'tag-guide' : kind === 'api' ? 'tag-api' : 'tag-meta';
  const tagLabel = kind === 'guide' ? 'Guide' : kind === 'api' ? 'Source' : 'Meta';

  let date = '';
  if (r.updated_at) {
    if (typeof r.updated_at === 'string') date = r.updated_at.split('T')[0];
    else if (typeof r.updated_at === 'number') date = new Date(r.updated_at * 1000).toISOString().split('T')[0];
  }

  let snippet = escapeHtml(r.snippet);
  if (query) {
    const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 1);
    terms.forEach(term => {
      const re = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      snippet = snippet.replace(re, '<mark>$1</mark>');
    });
  }

  return `
    <div class="result-card" onclick="viewDocument('${r.id}')">
      <div class="result-header">
        <span class="result-title">${escapeHtml(r.title)}</span>
        <span class="result-score ${scoreClass}">${score}</span>
      </div>
      <div class="result-meta">
        <span class="result-tag ${tagClass}">${tagLabel}</span>
        <span>${r.source_id}</span>
        ${date ? `<span>${date}</span>` : ''}
      </div>
      <div class="result-snippet">${snippet}</div>
      ${r.source_url ? `<div class="result-source"><a href="${escapeHtml(r.source_url)}" target="_blank" rel="noopener" onclick="event.stopPropagation()">View source ‚Üí</a></div>` : ''}
    </div>
  `;
}

function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ‚îÄ‚îÄ Document View ‚îÄ‚îÄ
function viewDocument(id) {
  const doc = DATA.documents.find(d => d.id === id);
  if (!doc) return;

  document.getElementById('searchPage').style.display = 'none';
  document.getElementById('chatPage').classList.remove('active');
  document.getElementById('docView').classList.add('active');

  document.getElementById('docTitle').textContent = doc.title || doc.source_id;

  const kind = classifyDoc(doc.source_id);
  let date = '';
  if (doc.updated_at) {
    if (typeof doc.updated_at === 'number') date = new Date(doc.updated_at * 1000).toISOString().split('T')[0];
    else date = String(doc.updated_at).split('T')[0];
  }

  document.getElementById('docMeta').innerHTML = `
    <span class="result-tag ${kind === 'guide' ? 'tag-guide' : kind === 'api' ? 'tag-api' : 'tag-meta'}">${kind}</span>
    <span>${doc.source_id}</span>
    ${date ? `<span>${date}</span>` : ''}
    ${doc.source_url ? `<a href="${escapeHtml(doc.source_url)}" target="_blank" rel="noopener" style="color:var(--accent)">View on GitHub ‚Üí</a>` : ''}
  `;

  document.getElementById('docBody').textContent = doc.body;
  document.querySelectorAll('.sidebar-link').forEach(el => el.classList.remove('active'));
}

function showSearch() {
  document.getElementById('docView').classList.remove('active');
  if (currentMode === 'chat') {
    document.getElementById('chatPage').classList.add('active');
    document.getElementById('searchPage').style.display = 'none';
  } else {
    document.getElementById('searchPage').style.display = 'block';
    document.getElementById('chatPage').classList.remove('active');
    searchInput.focus();
  }
}

// ‚îÄ‚îÄ Mode & Filter Pills ‚îÄ‚îÄ
document.querySelectorAll('.mode-pill').forEach(pill => {
  pill.addEventListener('click', () => {
    document.querySelectorAll('.mode-pill').forEach(p => p.classList.remove('active'));
    pill.classList.add('active');
    currentMode = pill.dataset.mode;

    document.getElementById('docView').classList.remove('active');

    if (currentMode === 'chat') {
      document.getElementById('searchPage').style.display = 'none';
      document.getElementById('chatPage').classList.add('active');
      document.getElementById('chatInput').focus();
    } else {
      document.getElementById('chatPage').classList.remove('active');
      document.getElementById('searchPage').style.display = 'block';
      searchInput.focus();
      doSearch();
    }
  });
});

document.querySelectorAll('.filter-pill').forEach(pill => {
  pill.addEventListener('click', () => {
    document.querySelectorAll('.filter-pill').forEach(p => p.classList.remove('active'));
    pill.classList.add('active');
    currentFilter = pill.dataset.filter;
    doSearch();
  });
});

// ‚îÄ‚îÄ Keyboard Shortcut ‚îÄ‚îÄ
document.addEventListener('keydown', (e) => {
  if (e.key === '/' && document.activeElement !== searchInput && document.activeElement !== document.getElementById('chatInput')) {
    e.preventDefault();
    if (currentMode === 'chat') document.getElementById('chatInput').focus();
    else searchInput.focus();
  }
  if (e.key === 'Escape') {
    if (document.getElementById('docView').classList.contains('active')) showSearch();
    const dd = document.getElementById('settingsDropdown');
    if (dd.classList.contains('open')) dd.classList.remove('open');
  }
});

/* ====================================================================
   CHAT SYSTEM ‚Äî Agent with MCP Tool Calling
   The LLM calls search/get_document/list_sources tools in a loop,
   executing them client-side (from data.json) or against a local
   MCP server. This is the same tool protocol used by Cursor/Claude.
   ==================================================================== */

let chatHistory = [];   // { role, content, sources? }
let chatBackend = 'webllm';   // 'webllm' | 'openai'
let toolMode = 'local';       // 'local' | 'mcp'
let mcpServerUrl = 'http://localhost:3636';
let webllmEngine = null;
let webllmReady = false;
let webllmLoading = false;
let _webllmPromise = null;
let chatGenerating = false;

const MAX_TOOL_ROUNDS = 6;

// ‚îÄ‚îÄ MCP Tool Definitions (OpenAI function-calling format) ‚îÄ‚îÄ
const AGENT_TOOLS = [
  {
    type: 'function',
    function: {
      name: 'search',
      description: 'Search the Context Harness documentation index. Returns ranked document chunks with relevance scores. Use this to find information about features, configuration, APIs, architecture, and usage patterns. Always search before answering.',
      parameters: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Natural language search query. Be specific.' },
          mode:  { type: 'string', enum: ['keyword', 'hybrid'], description: 'Search mode. "hybrid" combines keyword + semantic for best results. Default: "hybrid".' },
          limit: { type: 'number', description: 'Max results to return. Default: 5.' }
        },
        required: ['query']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'get_document',
      description: 'Retrieve the full content of a specific document by its UUID. Use after search when you need more context than the snippet provides.',
      parameters: {
        type: 'object',
        properties: {
          id: { type: 'string', description: 'Document UUID from search results.' }
        },
        required: ['id']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'list_sources',
      description: 'List all configured data source connectors and how many documents each has indexed.',
      parameters: { type: 'object', properties: {} }
    }
  }
];

// ‚îÄ‚îÄ Agent System Prompt ‚îÄ‚îÄ
function buildAgentSystemPrompt() {
  return `You are an expert documentation assistant for Context Harness, a local-first context indexing and retrieval framework for AI tools, written in Rust.

You have access to tools that let you search and retrieve documentation. Use them to find accurate information before answering.

## How to use your tools:

1. **Always search first** ‚Äî use the \`search\` tool with a clear query before answering any question. Do not guess.
2. **Read full documents** ‚Äî if a search snippet looks relevant but incomplete, use \`get_document\` to read the full text.
3. **Try different queries** ‚Äî if your first search doesn't find what you need, rephrase and search again.
4. **Be thorough** ‚Äî it's better to search twice than to give an incomplete answer.

## Response guidelines:

- Be concise, accurate, and helpful.
- Use markdown: code blocks for code, bold for emphasis, lists for steps.
- Cite sources naturally (e.g., "According to USAGE.md‚Ä¶" or "The search module implements‚Ä¶").
- If you can't find the answer, say so honestly.
- Show exact configuration and code from the documentation when relevant.`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  Tool Execution Layer
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function executeToolCall(name, args) {
  if (toolMode === 'mcp') {
    try { return await executeToolViaMCP(name, args); }
    catch (e) {
      console.warn('MCP tool call failed, falling back to local:', e);
      return executeToolLocally(name, args);
    }
  }
  return executeToolLocally(name, args);
}

// ‚îÄ‚îÄ Client-side tool execution (from data.json) ‚îÄ‚îÄ
async function executeToolLocally(name, args) {
  if (name === 'search') {
    const mode = args.mode || 'hybrid';
    const limit = args.limit || 5;
    let results;
    if (mode === 'keyword') results = bm25Search(args.query || '');
    else results = await hybridSearch(args.query || '', limit);
    return { results: results.slice(0, limit) };
  }

  if (name === 'get_document') {
    const doc = DATA.documents.find(d => d.id === args.id);
    if (!doc) return { error: `Document not found: ${args.id}` };
    return {
      id: doc.id,
      title: doc.title,
      source: doc.source,
      source_id: doc.source_id,
      source_url: doc.source_url,
      body: doc.body,
      chunk_count: DATA.chunks.filter(c => c.document_id === doc.id).length
    };
  }

  if (name === 'list_sources') {
    const sourceMap = {};
    DATA.documents.forEach(d => {
      const src = d.source || 'unknown';
      if (!sourceMap[src]) sourceMap[src] = { name: src, document_count: 0 };
      sourceMap[src].document_count++;
    });
    return { sources: Object.values(sourceMap) };
  }

  return { error: `Unknown tool: ${name}` };
}

// ‚îÄ‚îÄ MCP server tool execution ‚îÄ‚îÄ
async function executeToolViaMCP(name, args) {
  const routes = { search: '/tools/search', get_document: '/tools/get', list_sources: '/tools/sources' };
  const endpoint = routes[name];
  if (!endpoint) return { error: `Unknown tool: ${name}` };

  const method = name === 'list_sources' ? 'GET' : 'POST';
  const resp = await fetch(mcpServerUrl + endpoint, {
    method,
    headers: { 'Content-Type': 'application/json' },
    body: method === 'POST' ? JSON.stringify(name === 'get_document' ? { id: args.id } : args) : undefined,
  });

  if (!resp.ok) {
    const err = await resp.json().catch(() => ({ error: { message: resp.statusText } }));
    throw new Error(err.error?.message || `MCP ${resp.status}`);
  }
  return resp.json();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  Tool Call UI
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function appendToolCallCard(bubble, tc) {
  const card = document.createElement('div');
  card.className = 'tool-call-card';

  const icons = { search: 'üîç', get_document: 'üìñ', list_sources: 'üìã' };
  const badges = { search: 'tool-badge-search', get_document: 'tool-badge-get', list_sources: 'tool-badge-list' };
  const icon = icons[tc.name] || 'üîß';
  const badgeClass = badges[tc.name] || 'tool-badge-search';

  let argsSummary = '';
  if (tc.name === 'search') argsSummary = `"${tc.args.query || ''}"`;
  else if (tc.name === 'get_document') argsSummary = tc.args.id ? tc.args.id.substring(0, 12) + '‚Ä¶' : '';

  card.innerHTML = `
    <div class="tool-call-header" onclick="this.parentElement.querySelector('.tool-call-detail')?.classList.toggle('open')">
      <span class="tool-call-icon">${icon}</span>
      <span class="tool-badge ${badgeClass}">${tc.name}</span>
      <span class="tool-call-args">${escapeHtml(argsSummary)}</span>
      <span class="tool-call-status">running‚Ä¶</span>
    </div>
    <div class="tool-call-detail"></div>
  `;

  bubble.appendChild(card);
  document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
  return card;
}

function updateToolCallCard(card, result, toolName) {
  const status = card.querySelector('.tool-call-status');
  const detail = card.querySelector('.tool-call-detail');

  if (result.error) {
    status.textContent = '‚úó error';
    status.classList.add('error');
    detail.textContent = result.error;
    detail.classList.add('open');
    return;
  }

  status.classList.add('success');

  if (toolName === 'search') {
    const n = result.results?.length || 0;
    status.textContent = `‚úì ${n} result${n !== 1 ? 's' : ''}`;
    if (n > 0) {
      detail.innerHTML = result.results.map(r =>
        `<div style="margin-bottom:4px"><strong>${escapeHtml(r.source_id || r.title || '')}</strong> <span style="color:var(--green)">${(r.score||0).toFixed(2)}</span></div><div style="color:var(--text-muted);margin-bottom:8px">${escapeHtml((r.snippet || r.text || '').substring(0, 150))}‚Ä¶</div>`
      ).join('');
    }
  } else if (toolName === 'get_document') {
    const title = result.source_id || result.title || result.id;
    const len = result.body ? result.body.length : 0;
    status.textContent = `‚úì ${len.toLocaleString()} chars`;
    detail.textContent = `${title}\n\n${(result.body || '').substring(0, 500)}‚Ä¶`;
  } else if (toolName === 'list_sources') {
    const n = result.sources?.length || 0;
    status.textContent = `‚úì ${n} source${n !== 1 ? 's' : ''}`;
    detail.textContent = (result.sources || []).map(s => `${s.name}: ${s.document_count} docs`).join('\n');
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  Chat Settings
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function initChatSettings() {
  // Restore backend
  const saved = localStorage.getItem('ctx_chat_backend');
  if (saved === 'openai' || saved === 'webllm') chatBackend = saved;

  // Restore tool mode
  const savedTool = localStorage.getItem('ctx_tool_mode');
  if (savedTool === 'mcp' || savedTool === 'local') toolMode = savedTool;

  // Restore MCP URL
  const savedUrl = localStorage.getItem('ctx_mcp_url');
  if (savedUrl) { mcpServerUrl = savedUrl; document.getElementById('mcpUrlInput').value = savedUrl; }

  // Restore API key
  const key = localStorage.getItem('ctx_chat_apikey');
  if (key) document.getElementById('apikeyInput').value = key;

  updateBackendUI();
  updateToolModeUI();

  // Settings toggle
  document.getElementById('settingsBtn').addEventListener('click', (e) => {
    e.stopPropagation();
    document.getElementById('settingsDropdown').classList.toggle('open');
  });
  document.addEventListener('click', (e) => {
    const dd = document.getElementById('settingsDropdown');
    if (dd.classList.contains('open') && !dd.contains(e.target) && e.target !== document.getElementById('settingsBtn')) {
      dd.classList.remove('open');
    }
  });

  // API key input
  document.getElementById('apikeyInput').addEventListener('input', (e) => {
    const key = e.target.value.trim();
    if (key) localStorage.setItem('ctx_chat_apikey', key);
    else localStorage.removeItem('ctx_chat_apikey');
    updateBackendUI();
  });

  // MCP URL input
  document.getElementById('mcpUrlInput').addEventListener('change', (e) => {
    mcpServerUrl = e.target.value.trim() || 'http://localhost:3636';
    localStorage.setItem('ctx_mcp_url', mcpServerUrl);
    if (toolMode === 'mcp') testMcpConnection();
  });

  // Chat input auto-resize
  const chatInput = document.getElementById('chatInput');
  chatInput.addEventListener('input', () => {
    chatInput.style.height = 'auto';
    chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
  });
  chatInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(); }
  });

  // If MCP mode was saved, test connection
  if (toolMode === 'mcp') testMcpConnection();
}

function selectBackend(backend) {
  chatBackend = backend;
  localStorage.setItem('ctx_chat_backend', backend);
  document.getElementById('radioWebllm').classList.toggle('selected', backend === 'webllm');
  document.getElementById('radioOpenai').classList.toggle('selected', backend === 'openai');
  document.getElementById('apikeyRow').classList.toggle('visible', backend === 'openai');
  updateBackendUI();
}

function selectToolMode(mode) {
  toolMode = mode;
  localStorage.setItem('ctx_tool_mode', mode);
  document.getElementById('radioLocal').classList.toggle('selected', mode === 'local');
  document.getElementById('radioMcp').classList.toggle('selected', mode === 'mcp');
  document.getElementById('mcpUrlRow').classList.toggle('visible', mode === 'mcp');
  updateToolModeUI();
  if (mode === 'mcp') testMcpConnection();
}

function updateToolModeUI() {
  document.getElementById('radioLocal').classList.toggle('selected', toolMode === 'local');
  document.getElementById('radioMcp').classList.toggle('selected', toolMode === 'mcp');
  document.getElementById('mcpUrlRow').classList.toggle('visible', toolMode === 'mcp');
}

async function testMcpConnection() {
  const el = document.getElementById('mcpStatus');
  el.textContent = 'Testing connection‚Ä¶';
  try {
    const resp = await fetch(mcpServerUrl + '/health', { signal: AbortSignal.timeout(3000) });
    if (resp.ok) {
      const data = await resp.json();
      el.innerHTML = `<span style="color:var(--green)">‚úì Connected</span> ‚Äî v${data.version || '?'}`;
    } else {
      el.innerHTML = `<span style="color:var(--red)">‚úó HTTP ${resp.status}</span>`;
    }
  } catch (e) {
    el.innerHTML = `<span style="color:var(--text-muted)">‚úó Not reachable</span> ‚Äî start <code style="font-size:10px">ctx serve mcp</code>`;
  }
}

function updateBackendUI() {
  const bdot = document.getElementById('chatBdot');
  const label = document.getElementById('chatBackendLabel');

  if (chatBackend === 'webllm') {
    document.getElementById('radioWebllm').classList.add('selected');
    document.getElementById('radioOpenai').classList.remove('selected');
    document.getElementById('apikeyRow').classList.remove('visible');
    if (webllmReady) {
      bdot.className = 'bdot bdot-ready'; label.textContent = 'WebLLM ready';
    } else if (webllmLoading) {
      bdot.className = 'bdot bdot-loading'; label.textContent = 'Loading model‚Ä¶';
    } else {
      bdot.className = 'bdot bdot-off';
      label.textContent = navigator.gpu ? 'WebLLM (click Send to load)' : 'WebGPU not supported ‚Äî use API key';
    }
  } else {
    document.getElementById('radioOpenai').classList.add('selected');
    document.getElementById('radioWebllm').classList.remove('selected');
    document.getElementById('apikeyRow').classList.add('visible');
    const key = localStorage.getItem('ctx_chat_apikey');
    bdot.className = key ? 'bdot bdot-ready' : 'bdot bdot-off';
    label.textContent = key ? 'OpenAI API ready' : 'Enter API key';
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  WebLLM Engine
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function ensureWebLLM() {
  if (webllmReady && webllmEngine) return webllmEngine;
  if (_webllmPromise) return _webllmPromise;

  if (!navigator.gpu) {
    throw new Error('WebGPU is not supported in this browser. Please use Chrome/Edge 113+ or switch to the OpenAI API backend.');
  }

  _webllmPromise = (async () => {
    webllmLoading = true;
    updateBackendUI();
    const prog = document.getElementById('chatLlmProgress');
    prog.classList.add('visible');

    try {
      const webllm = await import('https://esm.run/@mlc-ai/web-llm');
      const modelId = 'Qwen3-4B-q4f16_1-MLC';

      document.getElementById('chatProgDetail').textContent = 'Loading Qwen3-4B‚Ä¶';
      document.getElementById('chatProgFill').style.width = '5%';
      document.getElementById('chatProgPct').textContent = '5%';

      webllmEngine = await webllm.CreateMLCEngine(modelId, {
        initProgressCallback: (report) => {
          const pct = Math.round((report.progress || 0) * 100);
          document.getElementById('chatProgFill').style.width = pct + '%';
          document.getElementById('chatProgPct').textContent = pct + '%';
          document.getElementById('chatProgDetail').textContent = report.text || 'Loading‚Ä¶';
        }
      });

      webllmReady = true;
      webllmLoading = false;
      updateBackendUI();
      document.getElementById('chatProgFill').style.width = '100%';
      document.getElementById('chatProgPct').textContent = '100%';
      document.getElementById('chatProgDetail').textContent = 'Model ready!';
      setTimeout(() => prog.classList.remove('visible'), 1500);
      return webllmEngine;
    } catch (e) {
      webllmLoading = false;
      _webllmPromise = null;
      updateBackendUI();
      document.getElementById('chatProgDetail').textContent = `Error: ${e.message}`;
      document.getElementById('chatProgFill').style.background = 'var(--red)';
      throw e;
    }
  })();

  return _webllmPromise;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  Streaming with Tool Call Detection
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Unified stream parser: detects tool calls vs text content
async function parseStreamResponse(asyncIterator, bubble, existingContent) {
  let fullText = existingContent || '';
  const toolCalls = {};
  let hasToolCalls = false;

  for await (const chunk of asyncIterator) {
    const choice = chunk.choices?.[0];
    if (!choice) continue;
    const delta = choice.delta || {};

    // Accumulate tool call deltas
    if (delta.tool_calls) {
      hasToolCalls = true;
      for (const tc of delta.tool_calls) {
        const idx = tc.index ?? 0;
        if (!toolCalls[idx]) toolCalls[idx] = { id: '', name: '', arguments: '' };
        if (tc.id) toolCalls[idx].id = tc.id;
        if (tc.function?.name) toolCalls[idx].name += tc.function.name;
        if (tc.function?.arguments != null) toolCalls[idx].arguments += tc.function.arguments;
      }
    }

    // Stream text content
    if (delta.content) {
      fullText += delta.content;
      bubble.innerHTML = renderMarkdown(fullText) + '<span style="opacity:0.4">‚ñå</span>';
      document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
    }
  }

  if (hasToolCalls) {
    const calls = Object.values(toolCalls).map(tc => ({
      id: tc.id || `call_${Date.now()}_${tc.name}`,
      name: tc.name,
      args: (() => { try { return JSON.parse(tc.arguments || '{}'); } catch { return {}; } })(),
    }));
    return { type: 'tool_calls', calls };
  }

  return { type: 'text', text: fullText };
}

// OpenAI streaming ‚Üí async iterator of parsed chunks
async function* streamOpenAIChunks(resp) {
  const reader = resp.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed === 'data: [DONE]') continue;
      if (!trimmed.startsWith('data: ')) continue;
      try { yield JSON.parse(trimmed.slice(6)); } catch { /* skip */ }
    }
  }
}

// Call OpenAI with tools, return parsed stream result
async function openaiWithTools(messages, bubble, forceNoTools) {
  const apiKey = localStorage.getItem('ctx_chat_apikey');
  if (!apiKey) throw new Error('No OpenAI API key configured. Open Settings to add one.');

  const body = {
    model: 'gpt-4o-mini',
    messages,
    stream: true,
    max_tokens: 2048,
    temperature: 0.3,
  };
  if (!forceNoTools) {
    body.tools = AGENT_TOOLS;
    body.tool_choice = 'auto';
  }

  const resp = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
    body: JSON.stringify(body),
  });

  if (!resp.ok) {
    const err = await resp.text();
    throw new Error(`OpenAI API error (${resp.status}): ${err}`);
  }

  return parseStreamResponse(streamOpenAIChunks(resp), bubble, '');
}

// Call WebLLM with tools, return parsed stream result
async function webllmWithTools(messages, bubble, forceNoTools) {
  const engine = await ensureWebLLM();

  const opts = { messages, stream: true, max_tokens: 2048, temperature: 0.3 };
  if (!forceNoTools) {
    opts.tools = AGENT_TOOLS;
    opts.tool_choice = 'auto';
  }

  let completion;
  try {
    completion = await engine.chat.completions.create(opts);
  } catch (e) {
    // If model doesn't support tools, retry without
    if (!forceNoTools && (e.message?.includes('tool') || e.message?.includes('function'))) {
      console.warn('WebLLM tool calling failed, retrying without tools:', e.message);
      delete opts.tools;
      delete opts.tool_choice;
      completion = await engine.chat.completions.create(opts);
    } else {
      throw e;
    }
  }

  return parseStreamResponse(completion, bubble, '');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  Agent Loop
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function agentLoop(query, bubble) {
  const systemPrompt = buildAgentSystemPrompt();
  const messages = [
    { role: 'system', content: systemPrompt },
    ...chatHistory.slice(-12).map(m => ({ role: m.role, content: m.content })),
    { role: 'user', content: query },
  ];

  const allSources = [];
  // Track content that tool cards have built up in the bubble
  let toolCardsHTML = '';

  for (let round = 0; round < MAX_TOOL_ROUNDS; round++) {
    // Show thinking state (keep existing tool cards)
    if (round === 0) {
      bubble.innerHTML = '<div class="tool-thinking"><span class="tool-thinking-spinner"></span> Analyzing question‚Ä¶</div>';
    } else {
      // Preserve tool cards, update thinking indicator
      const existing = bubble.querySelectorAll('.tool-call-card');
      // Thinking indicator is managed by stream parser
    }

    // On last round, force text output
    const forceNoTools = round === MAX_TOOL_ROUNDS - 1;

    let result;
    if (chatBackend === 'openai') {
      result = await openaiWithTools(messages, bubble, forceNoTools);
    } else {
      result = await webllmWithTools(messages, bubble, forceNoTools);
    }

    if (result.type === 'text') {
      return { text: result.text, sources: allSources };
    }

    // ‚îÄ‚îÄ Execute tool calls ‚îÄ‚îÄ
    // Clear the thinking indicator, restore tool cards
    bubble.innerHTML = toolCardsHTML;

    for (const tc of result.calls) {
      // Show tool call card
      const card = appendToolCallCard(bubble, tc);

      // Execute tool
      const toolResult = await executeToolCall(tc.name, tc.args);

      // Update card with results
      updateToolCallCard(card, toolResult, tc.name);

      // Collect sources from search results
      if (tc.name === 'search' && toolResult.results) {
        for (const r of toolResult.results) {
          if (!allSources.find(s => s.id === r.id && s.chunk_index === r.chunk_index)) {
            allSources.push(r);
          }
        }
      }

      // Add to LLM message history
      messages.push({
        role: 'assistant',
        content: null,
        tool_calls: [{
          id: tc.id,
          type: 'function',
          function: { name: tc.name, arguments: JSON.stringify(tc.args) }
        }]
      });
      messages.push({
        role: 'tool',
        tool_call_id: tc.id,
        content: JSON.stringify(toolResult)
      });
    }

    // Save the current bubble HTML (tool cards) so we can preserve them
    toolCardsHTML = bubble.innerHTML;

    // Add divider before next round or final response
    const divider = document.createElement('div');
    divider.className = 'agent-divider';
    bubble.appendChild(divider);
    toolCardsHTML = bubble.innerHTML;
  }

  return { text: '*(Reached maximum tool iterations. Try a more specific question.)*', sources: allSources };
}

// Fallback: one-shot RAG (no tool calling)
async function fallbackRAG(query, bubble) {
  const results = await hybridSearch(query, 5);
  const seen = new Set();
  const unique = [];
  for (const r of results) {
    const key = r.id + ':' + r.chunk_index;
    if (!seen.has(key)) { seen.add(key); unique.push(r); }
  }
  const contextChunks = unique.slice(0, 5);

  let contextBlock = contextChunks.length === 0
    ? '(No relevant documentation found.)'
    : contextChunks.map((c, i) => `### Source ${i + 1}: ${c.source_id}\n${c.text}`).join('\n\n');

  const systemPrompt = `You are a documentation assistant for Context Harness, a local-first context indexing framework in Rust.
Answer using ONLY the documentation below. Be concise and use markdown.

## Documentation Context

${contextBlock}`;

  const messages = [
    { role: 'system', content: systemPrompt },
    ...chatHistory.slice(-12).map(m => ({ role: m.role, content: m.content })),
    { role: 'user', content: query },
  ];

  let fullText = '';
  if (chatBackend === 'openai') {
    const apiKey = localStorage.getItem('ctx_chat_apikey');
    if (!apiKey) throw new Error('No OpenAI API key. Open Settings.');
    const resp = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
      body: JSON.stringify({ model: 'gpt-4o-mini', messages, stream: true, max_tokens: 2048, temperature: 0.3 }),
    });
    if (!resp.ok) throw new Error(`OpenAI error ${resp.status}`);
    const result = await parseStreamResponse(streamOpenAIChunks(resp), bubble, '');
    fullText = result.text;
  } else {
    const engine = await ensureWebLLM();
    const completion = await engine.chat.completions.create({ messages, stream: true, max_tokens: 2048, temperature: 0.3 });
    const result = await parseStreamResponse(completion, bubble, '');
    fullText = result.text;
  }

  return { text: fullText, sources: contextChunks };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  Markdown Renderer
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderMarkdown(text) {
  let html = escapeHtml(text);

  // Code blocks
  html = html.replace(/```(\w*)\n([\s\S]*?)```/g, (_, lang, code) => `<pre><code>${code.trim()}</code></pre>`);

  // Inline code
  html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

  // Headers
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

  // Bold and italic
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // Blockquotes
  html = html.replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>');

  // Unordered lists
  html = html.replace(/^- (.+)$/gm, '<li>$1</li>');
  html = html.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');

  // Ordered lists
  html = html.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');

  // Links
  html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');

  // Paragraphs
  html = html.replace(/\n\n/g, '</p><p>');
  html = '<p>' + html + '</p>';

  // Clean up
  html = html.replace(/<p>\s*<(h[123]|pre|ul|ol|blockquote)/g, '<$1');
  html = html.replace(/<\/(h[123]|pre|ul|ol|blockquote)>\s*<\/p>/g, '</$1>');
  html = html.replace(/<p>\s*<\/p>/g, '');

  return html;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  Chat Message Rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function appendUserMessage(text) {
  const welcome = document.getElementById('chatWelcome');
  if (welcome) welcome.remove();

  const container = document.getElementById('chatMessages');
  const div = document.createElement('div');
  div.className = 'chat-msg chat-msg-user';
  div.innerHTML = `
    <div class="chat-bubble bubble-user">${escapeHtml(text)}</div>
    <div class="chat-avatar avatar-user">U</div>
  `;
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
}

function createAssistantBubble() {
  const container = document.getElementById('chatMessages');
  const div = document.createElement('div');
  div.className = 'chat-msg chat-msg-assistant';
  div.innerHTML = `
    <div class="chat-avatar avatar-assistant">‚ö°</div>
    <div class="chat-bubble bubble-assistant">
      <div class="typing-indicator"><span></span><span></span><span></span></div>
    </div>
  `;
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
  return div.querySelector('.bubble-assistant');
}

function updateAssistantBubble(bubble, text, sources) {
  // Preserve tool call cards, replace or append the text response
  const existingCards = bubble.querySelectorAll('.tool-call-card, .agent-divider');
  const fragment = document.createDocumentFragment();
  existingCards.forEach(card => fragment.appendChild(card.cloneNode(true)));

  bubble.innerHTML = '';
  bubble.appendChild(fragment);

  // Add text response
  if (text) {
    const responseDiv = document.createElement('div');
    responseDiv.innerHTML = renderMarkdown(text);
    bubble.appendChild(responseDiv);
  }

  // Add source links
  if (sources && sources.length > 0) {
    // Deduplicate sources by document id
    const seen = new Set();
    const uniqueSources = [];
    for (const s of sources) {
      if (!seen.has(s.id)) { seen.add(s.id); uniqueSources.push(s); }
    }
    if (uniqueSources.length > 0) {
      const srcDiv = document.createElement('div');
      srcDiv.className = 'chat-sources';
      srcDiv.innerHTML = `
        <div class="chat-sources-title">Sources</div>
        ${uniqueSources.map(s =>
          `<a class="chat-source-link" onclick="viewDocument('${s.id}')" title="${s.source_id}">${s.source_id}</a>`
        ).join('')}
      `;
      bubble.appendChild(srcDiv);
    }
  }

  document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  Send Message (entry point)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function sendChatMessage() {
  const input = document.getElementById('chatInput');
  const query = input.value.trim();
  if (!query || chatGenerating) return;

  chatGenerating = true;
  document.getElementById('chatSend').disabled = true;
  input.value = '';
  input.style.height = 'auto';

  appendUserMessage(query);
  chatHistory.push({ role: 'user', content: query });

  const bubble = createAssistantBubble();

  try {
    // Try agent loop with tool calling
    const result = await agentLoop(query, bubble);
    updateAssistantBubble(bubble, result.text, result.sources);
    chatHistory.push({ role: 'assistant', content: result.text, sources: result.sources });
  } catch (e) {
    console.warn('Agent loop error:', e);
    // Fall back to one-shot RAG if tool calling fails
    try {
      bubble.innerHTML = '<div class="tool-thinking"><span class="tool-thinking-spinner"></span> Falling back to direct search‚Ä¶</div>';
      const result = await fallbackRAG(query, bubble);
      updateAssistantBubble(bubble, result.text, result.sources);
      chatHistory.push({ role: 'assistant', content: result.text, sources: result.sources });
    } catch (e2) {
      bubble.innerHTML = `<div style="color:var(--red)">Error: ${escapeHtml(e2.message)}</div>`;
      console.error('Fallback RAG also failed:', e2);
    }
  }

  chatGenerating = false;
  document.getElementById('chatSend').disabled = false;
  input.focus();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  Chat Utilities
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function clearChat() {
  chatHistory = [];
  const container = document.getElementById('chatMessages');
  container.innerHTML = `
    <div class="chat-welcome" id="chatWelcome">
      <div class="chat-welcome-title">Agent-Powered Documentation Chat</div>
      <div class="chat-welcome-sub">
        Ask questions and watch the agent use Context Harness MCP tools ‚Äî search, retrieve, and synthesize answers.
        The same tools available to Cursor and other AI editors, running right here in your browser.
      </div>
      <div class="chat-suggestions" id="chatSuggestions">
        <button class="chat-suggestion" onclick="askSuggestion(this)">How do I set up the Git connector?</button>
        <button class="chat-suggestion" onclick="askSuggestion(this)">What search modes are available?</button>
        <button class="chat-suggestion" onclick="askSuggestion(this)">Show me the S3 connector config</button>
        <button class="chat-suggestion" onclick="askSuggestion(this)">How does the chunking algorithm work?</button>
      </div>
    </div>
  `;
}

function askSuggestion(btn) {
  document.getElementById('chatInput').value = btn.textContent;
  sendChatMessage();
}

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ
init();
</script>
</body>
</html>
