<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Live Demo — Context Harness</title>
<meta name="description" content="Try Context Harness in your browser. Search a pre-built knowledge base with keyword, semantic, and hybrid modes — entirely client-side.">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⚡</text></svg>">
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #0a0a0f;
    --bg-card: #12121a;
    --bg-hover: #1a1a25;
    --text: #e4e4ec;
    --text-dim: #8888a0;
    --text-muted: #55556a;
    --accent: #4f8fff;
    --accent-bright: #6ba3ff;
    --accent-glow: rgba(79, 143, 255, 0.12);
    --green: #4ade80;
    --yellow: #facc15;
    --red: #f87171;
    --border: #1e1e2e;
    --border-light: #2a2a3a;
    --radius: 10px;
    --font: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    --mono: 'JetBrains Mono', 'SF Mono', 'Fira Code', monospace;
  }

  html { scroll-behavior: smooth; }

  body {
    font-family: var(--font);
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
    -webkit-font-smoothing: antialiased;
    min-height: 100vh;
  }

  a { color: var(--accent); text-decoration: none; }
  a:hover { color: var(--accent-bright); }

  /* ── Header ── */
  .header {
    position: sticky; top: 0; z-index: 100;
    background: rgba(10, 10, 15, 0.92);
    backdrop-filter: blur(16px);
    border-bottom: 1px solid var(--border);
    padding: 0 24px; height: 56px;
    display: flex; align-items: center;
  }
  .header-inner {
    width: 100%; max-width: 860px; margin: 0 auto;
    display: flex; align-items: center; justify-content: space-between;
  }
  .header-left { display: flex; align-items: center; gap: 14px; }
  .brand {
    display: flex; align-items: center; gap: 8px;
    color: var(--text); font-weight: 700; font-size: 16px; text-decoration: none;
  }
  .brand:hover { color: var(--text); }
  .header-sep { color: var(--text-muted); font-weight: 300; }
  .header-tag { color: var(--text-dim); font-size: 14px; font-weight: 500; }
  .header-links { display: flex; align-items: center; gap: 18px; }
  .header-links a { color: var(--text-dim); font-size: 13px; font-weight: 500; }
  .header-links a:hover { color: var(--text); text-decoration: none; }
  .status {
    display: flex; align-items: center; gap: 6px;
    padding: 3px 10px; border-radius: 16px;
    background: var(--bg-card); border: 1px solid var(--border);
    font-size: 11px; color: var(--text-muted); font-family: var(--mono);
  }
  .status-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--green); }

  /* ── Main ── */
  .main { max-width: 860px; margin: 0 auto; padding: 40px 24px 80px; }

  .intro {
    text-align: center; margin-bottom: 36px;
  }
  .intro h1 {
    font-size: 26px; font-weight: 800; letter-spacing: -0.3px; margin-bottom: 8px;
  }
  .intro p { color: var(--text-dim); font-size: 15px; max-width: 540px; margin: 0 auto; }
  .intro code {
    font-family: var(--mono); font-size: 0.88em;
    background: var(--bg-card); padding: 2px 7px; border-radius: 4px; color: var(--accent-bright);
  }

  /* ── Search ── */
  .search-bar {
    display: flex; gap: 0;
    background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius);
    overflow: hidden; transition: border-color 0.2s;
  }
  .search-bar:focus-within { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow); }
  .search-input {
    flex: 1; padding: 14px 18px; background: none; border: none;
    color: var(--text); font-size: 16px; outline: none; font-family: inherit;
  }
  .search-input::placeholder { color: var(--text-muted); }
  .search-btn {
    padding: 14px 22px; background: var(--accent); color: #fff; border: none;
    font-size: 14px; font-weight: 600; cursor: pointer; transition: background 0.15s;
  }
  .search-btn:hover { background: var(--accent-bright); }

  /* ── Mode Switcher ── */
  .controls {
    display: flex; align-items: center; gap: 10px; margin-top: 14px; flex-wrap: wrap;
  }
  .controls-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); font-weight: 600; }
  .mode-btn {
    padding: 6px 16px; border-radius: 16px;
    border: 1px solid var(--border); background: var(--bg-card);
    color: var(--text-dim); font-size: 13px; font-family: var(--mono);
    cursor: pointer; transition: all 0.15s;
  }
  .mode-btn:hover { border-color: var(--accent); color: var(--text); }
  .mode-btn.active { background: var(--accent-glow); border-color: var(--accent); color: var(--accent); }
  .mode-note {
    margin-left: auto; font-size: 12px; color: var(--text-muted); font-family: var(--mono);
  }

  /* ── Model loading ── */
  .model-bar {
    display: none; margin-top: 12px; padding: 12px 16px;
    background: var(--bg-card); border: 1px solid rgba(79,143,255,0.2); border-radius: var(--radius);
    font-size: 13px; color: var(--text-dim);
  }
  .model-bar.visible { display: block; }
  .prog-track { height: 4px; background: rgba(255,255,255,0.06); border-radius: 2px; margin-top: 8px; overflow: hidden; }
  .prog-fill { height: 100%; background: var(--accent); border-radius: 2px; width: 0%; transition: width 0.3s; }

  /* ── Stats bar ── */
  .stats {
    display: none; gap: 16px; margin-top: 12px;
    font-size: 12px; font-family: var(--mono); color: var(--text-muted);
  }
  .stats.visible { display: flex; flex-wrap: wrap; }
  .stats span { color: var(--accent); font-weight: 600; }

  /* ── Suggestions ── */
  .suggestions {
    display: flex; flex-wrap: wrap; justify-content: center; gap: 8px;
    margin-top: 24px;
  }
  .sug {
    padding: 7px 14px; border-radius: 16px;
    border: 1px solid var(--border); background: var(--bg-card);
    color: var(--text-dim); font-size: 13px; cursor: pointer; transition: all 0.15s;
  }
  .sug:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-glow); }

  .empty { text-align: center; padding: 48px 24px; color: var(--text-muted); }
  .empty h3 { color: var(--text-dim); font-size: 16px; margin-bottom: 6px; }
  .empty p { font-size: 14px; }

  /* ── Results ── */
  .results { margin-top: 20px; }

  .result {
    background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius);
    padding: 16px 18px; margin-bottom: 8px; cursor: pointer; transition: all 0.15s;
  }
  .result:hover { border-color: var(--border-light); transform: translateY(-1px); box-shadow: 0 4px 16px rgba(0,0,0,0.3); }
  .result-top { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 4px; }
  .result-title { font-weight: 600; font-size: 15px; }
  .result-score {
    font-family: var(--mono); font-size: 11px; font-weight: 600;
    padding: 2px 8px; border-radius: 10px; flex-shrink: 0; margin-left: 12px;
  }
  .s-hi { background: rgba(74,222,128,0.12); color: var(--green); }
  .s-md { background: rgba(250,204,21,0.12); color: var(--yellow); }
  .s-lo { background: rgba(248,113,113,0.12); color: var(--red); }
  .result-meta {
    display: flex; gap: 12px; font-size: 12px; color: var(--text-muted);
    font-family: var(--mono); margin-bottom: 6px;
  }
  .result-snippet {
    font-size: 13px; color: var(--text-dim); line-height: 1.6;
    border-left: 2px solid var(--border); padding-left: 12px;
  }
  .result-body {
    display: none; margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border);
  }
  .result-body.open { display: block; }
  .result-body-text {
    background: rgba(255,255,255,0.02); border: 1px solid var(--border); border-radius: 8px;
    padding: 16px; font-size: 13px; line-height: 1.7; font-family: var(--mono);
    max-height: 300px; overflow-y: auto; white-space: pre-wrap; color: var(--text-dim);
  }
  .chunk-tags { margin-bottom: 8px; }
  .chunk-tag {
    display: inline-block; padding: 2px 8px; border-radius: 4px;
    background: rgba(255,255,255,0.03); border: 1px solid var(--border);
    font-size: 11px; font-family: var(--mono); color: var(--text-muted); margin: 2px 3px 2px 0;
  }

  .error {
    text-align: center; padding: 20px; color: var(--red);
    background: rgba(248,113,113,0.06); border: 1px solid rgba(248,113,113,0.15);
    border-radius: var(--radius); font-family: var(--mono); font-size: 13px;
  }

  .spinner { width: 24px; height: 24px; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.7s linear infinite; margin: 0 auto 10px; }
  @keyframes spin { to { transform: rotate(360deg); } }

  @media (max-width: 600px) {
    .main { padding: 24px 16px 60px; }
    .intro h1 { font-size: 22px; }
    .result-top { flex-direction: column; gap: 4px; }
    .result-score { margin-left: 0; }
    .header-tag { display: none; }
  }
</style>
</head>
<body>

<header class="header">
  <div class="header-inner">
    <div class="header-left">
      <a href="../" class="brand">⚡ Context Harness</a>
      <span class="header-sep">/</span>
      <span class="header-tag">Demo</span>
    </div>
    <div class="header-links">
      <a href="../docs/">Docs</a>
      <a href="../api/context_harness/">API</a>
      <div class="status">
        <div class="status-dot"></div>
        <span id="statusText">loading…</span>
      </div>
    </div>
  </div>
</header>

<div class="main">
  <div class="intro">
    <h1>Search a pre-built knowledge base</h1>
    <p>11 documents from a fictional engineering handbook, indexed with <code>ctx sync</code> and exported as JSON. Everything runs in your browser — no server, no API keys.</p>
  </div>

  <div class="search-bar">
    <input type="text" class="search-input" id="searchInput"
           placeholder="Search the Acme Engineering Handbook…" autocomplete="off">
    <button class="search-btn" onclick="doSearch()">Search</button>
  </div>

  <div class="controls">
    <span class="controls-label">Mode</span>
    <button class="mode-btn active" data-mode="keyword" onclick="setMode(this)">keyword</button>
    <button class="mode-btn" data-mode="semantic" onclick="setMode(this)">semantic</button>
    <button class="mode-btn" data-mode="hybrid" onclick="setMode(this)">hybrid</button>
    <span class="mode-note" id="modeNote">BM25 · instant</span>
  </div>

  <div class="model-bar" id="modelBar">
    <span id="modelText">Loading embedding model…</span>
    <div class="prog-track"><div class="prog-fill" id="progFill"></div></div>
  </div>

  <div class="stats" id="stats">
    <div><span id="statCount">0</span> results</div>
    <div>mode: <span id="statMode">keyword</span></div>
    <div><span id="statTime">0</span>ms</div>
    <div>engine: <span>browser</span></div>
  </div>

  <div id="suggestionsArea">
    <div class="empty">
      <h3>Try a search</h3>
      <p>Click a suggestion or type your own query:</p>
      <div class="suggestions">
        <button class="sug" onclick="trySuggestion(this)">incident response</button>
        <button class="sug" onclick="trySuggestion(this)">Kafka consumer lag</button>
        <button class="sug" onclick="trySuggestion(this)">Rust error handling</button>
        <button class="sug" onclick="trySuggestion(this)">deployment rollback</button>
        <button class="sug" onclick="trySuggestion(this)">API authentication</button>
        <button class="sug" onclick="trySuggestion(this)">what happens when things break</button>
      </div>
    </div>
  </div>

  <div class="results" id="resultsArea"></div>
</div>

<script type="module">

// ── State ──
let DATA = null, bm25 = null, pipe = null, chunkEmbs = null;
let mode = 'keyword', modelReady = false, modelPromise = null;
const ALPHA = 0.6, K1 = 1.2, B = 0.75;

const MODE_NOTES = {
  keyword: 'BM25 · instant',
  semantic: 'cosine similarity · embedding model',
  hybrid: 'BM25 + cosine · α=0.6',
};

// ── Tokenizer + BM25 ──
function tokenize(t) { return t.toLowerCase().replace(/[^a-z0-9\s]/g,' ').split(/\s+/).filter(w=>w.length>1); }

function buildBM25(chunks) {
  const N = chunks.length, df = {}, tfs = [], lens = [];
  for (const c of chunks) {
    const tok = tokenize(c.text); lens.push(tok.length);
    const tf = {}, seen = new Set();
    for (const w of tok) { tf[w]=(tf[w]||0)+1; if(!seen.has(w)){df[w]=(df[w]||0)+1;seen.add(w);} }
    tfs.push(tf);
  }
  const avgdl = lens.reduce((a,b)=>a+b,0)/N;
  const idf = {};
  for (const [w,n] of Object.entries(df)) idf[w]=Math.log((N-n+0.5)/(n+0.5)+1);
  return { idf, avgdl, tfs, lens };
}

function bm25Score(queryTok, i) {
  let s = 0;
  for (const q of queryTok) {
    const tf = bm25.tfs[i][q]||0;
    if (!tf) continue;
    s += (bm25.idf[q]||0)*((tf*(K1+1))/(tf+K1*(1-B+B*bm25.lens[i]/bm25.avgdl)));
  }
  return s;
}

function bm25Search(query, limit=12) {
  const qt = tokenize(query); if (!qt.length) return [];
  const scored = [];
  for (let i=0; i<DATA.chunks.length; i++) { const s=bm25Score(qt,i); if(s>0) scored.push({i,s}); }
  scored.sort((a,b)=>b.s-a.s);
  return groupDocs(scored, limit);
}

// ── Semantic ──
function cosine(a,b) { let d=0,na=0,nb=0; for(let i=0;i<a.length;i++){d+=a[i]*b[i];na+=a[i]*a[i];nb+=b[i]*b[i];} const dn=Math.sqrt(na)*Math.sqrt(nb); return dn?d/dn:0; }

async function semSearch(query, limit=12) {
  await ensureModel();
  const r = await pipe(query, {pooling:'mean',normalize:true});
  const qv = Array.from(r.data);
  const scored = [];
  for (let i=0; i<chunkEmbs.length; i++) { const s=cosine(qv,chunkEmbs[i]); if(s>0) scored.push({i,s}); }
  scored.sort((a,b)=>b.s-a.s);
  return groupDocs(scored, limit);
}

async function hybridSearch(query, limit=12) {
  await ensureModel();
  const qt = tokenize(query);
  const kw = DATA.chunks.map((_,i)=>bm25Score(qt,i));
  const r = await pipe(query, {pooling:'mean',normalize:true});
  const qv = Array.from(r.data);
  const sem = chunkEmbs.map(e=>cosine(qv,e));
  const norm = arr => { const vs=arr.filter(v=>v>0); if(!vs.length) return arr.map(()=>0); const mn=Math.min(...vs),mx=Math.max(...vs); if(mx===mn) return arr.map(v=>v>0?1:0); return arr.map(v=>v>0?(v-mn)/(mx-mn):0); };
  const kn=norm(kw), sn=norm(sem);
  const scored = [];
  for (let i=0;i<DATA.chunks.length;i++) { const s=(1-ALPHA)*kn[i]+ALPHA*sn[i]; if(s>0) scored.push({i,s}); }
  scored.sort((a,b)=>b.s-a.s);
  return groupDocs(scored, limit);
}

// ── Group by document ──
function groupDocs(scored, limit) {
  const m = {};
  for (const {i,s} of scored) {
    const did = DATA.chunks[i].document_id;
    if (!m[did]||s>m[did].s) m[did]={did,s,ci:i};
  }
  const res = Object.values(m).sort((a,b)=>b.s-a.s).slice(0,limit);
  const mx = res.length ? res[0].s : 1;
  return res.map(r => {
    const doc = DATA.documents.find(d=>d.id===r.did);
    const chunk = DATA.chunks[r.ci];
    return { id:doc.id, score:mx>0?r.s/mx:0, title:doc.title, source:doc.source, source_id:doc.source_id,
      updated_at:doc.updated_at, snippet:chunk.text.substring(0,280)+(chunk.text.length>280?'…':''),
      body:doc.body, chunks:DATA.chunks.filter(c=>c.document_id===doc.id) };
  });
}

// ── Model ──
async function ensureModel() {
  if (modelReady && pipe && chunkEmbs) return;
  if (modelPromise) return modelPromise;
  modelPromise = loadModel();
  return modelPromise;
}

async function loadModel() {
  const bar = document.getElementById('modelBar');
  const fill = document.getElementById('progFill');
  const txt = document.getElementById('modelText');
  bar.classList.add('visible');

  try {
    txt.textContent = 'Loading Transformers.js…';
    fill.style.width = '10%';
    const { pipeline: createPipeline, env } = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.5.1/dist/transformers.min.js');
    env.allowLocalModels = false;

    txt.textContent = 'Downloading embedding model (~30 MB, cached)…';
    fill.style.width = '20%';
    pipe = await createPipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2', {
      progress_callback: p => { if (p.status==='progress'&&p.progress) { fill.style.width=Math.round(20+p.progress*0.4)+'%'; } }
    });

    // Check localStorage cache
    const cached = loadCachedEmbs();
    if (cached) {
      chunkEmbs = cached;
      fill.style.width = '100%';
      txt.textContent = 'Ready (embeddings from cache)';
    } else {
      txt.textContent = `Embedding ${DATA.chunks.length} chunks…`;
      fill.style.width = '60%';
      chunkEmbs = [];
      for (let i=0; i<DATA.chunks.length; i++) {
        const r = await pipe(DATA.chunks[i].text, {pooling:'mean',normalize:true});
        chunkEmbs.push(Array.from(r.data));
        fill.style.width = Math.round(60+((i+1)/DATA.chunks.length)*40)+'%';
      }
      try { localStorage.setItem('ctx_demo_embs',JSON.stringify(chunkEmbs)); localStorage.setItem('ctx_demo_hash',DATA.chunks.map(c=>c.id).join(',')); } catch(e){}
      txt.textContent = 'Ready';
    }

    modelReady = true;
    setTimeout(()=>bar.classList.remove('visible'), 1500);
  } catch(e) {
    txt.textContent = 'Model load failed: ' + e.message;
    fill.style.width = '100%'; fill.style.background = 'var(--red)';
    modelPromise = null;
    throw e;
  }
}

function loadCachedEmbs() {
  try {
    const h = localStorage.getItem('ctx_demo_hash');
    if (h === DATA.chunks.map(c=>c.id).join(',')) {
      const c = JSON.parse(localStorage.getItem('ctx_demo_embs'));
      if (c && c.length === DATA.chunks.length) return c;
    }
  } catch(e) {}
  return null;
}

// ── UI ──
window.setMode = function(btn) {
  document.querySelectorAll('.mode-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  mode = btn.dataset.mode;
  document.getElementById('modeNote').textContent = MODE_NOTES[mode];
};

window.trySuggestion = function(btn) {
  document.getElementById('searchInput').value = btn.textContent;
  doSearch();
};

window.toggleBody = function(idx) {
  const el = document.getElementById('body-'+idx);
  if (el.classList.contains('open')) { el.classList.remove('open'); return; }
  if (!el.dataset.loaded) {
    const data = JSON.parse(el.dataset.doc);
    el.innerHTML = `<div class="chunk-tags">${data.chunks.map(c=>`<span class="chunk-tag">chunk ${c.chunk_index} · ${c.text.length} chars</span>`).join('')}</div><div class="result-body-text">${esc(data.body)}</div>`;
    el.dataset.loaded = '1';
  }
  el.classList.add('open');
};

window.doSearch = async function() {
  const q = document.getElementById('searchInput').value.trim();
  if (!q || !DATA) return;
  const area = document.getElementById('resultsArea');
  document.getElementById('suggestionsArea').style.display = 'none';
  area.innerHTML = '<div style="text-align:center;padding:40px;color:var(--text-muted)"><div class="spinner"></div>Searching…</div>';
  document.getElementById('stats').classList.remove('visible');

  const t0 = performance.now();
  try {
    let results;
    if (mode === 'keyword') results = bm25Search(q);
    else if (mode === 'semantic') results = await semSearch(q);
    else results = await hybridSearch(q);
    const ms = Math.round(performance.now()-t0);

    document.getElementById('stats').classList.add('visible');
    document.getElementById('statCount').textContent = results.length;
    document.getElementById('statMode').textContent = mode;
    document.getElementById('statTime').textContent = ms;

    if (!results.length) {
      area.innerHTML = `<div class="empty"><h3>No results</h3><p>${mode==='keyword'?'No exact matches. Try <strong>semantic</strong> mode for conceptual search.':'Try different terms or a different mode.'}</p></div>`;
      return;
    }

    area.innerHTML = results.map((r,i)=>renderResult(r,i)).join('');
  } catch(e) {
    console.error(e);
    area.innerHTML = `<div class="error">${e.message.includes('model')||e.message.includes('pipeline') ? 'Failed to load embedding model. Try keyword mode or refresh.' : 'Search error: '+esc(e.message)}</div>`;
  }
};

function renderResult(r, i) {
  const sc = r.score.toFixed(2);
  const cls = r.score>=0.7?'s-hi':r.score>=0.4?'s-md':'s-lo';
  let date = '';
  if (r.updated_at) {
    date = typeof r.updated_at==='string' ? r.updated_at.split('T')[0] : new Date(r.updated_at*1000).toISOString().split('T')[0];
  }
  return `<div class="result" onclick="toggleBody(${i})">
    <div class="result-top">
      <span class="result-title">${esc(r.title)}</span>
      <span class="result-score ${cls}">${sc}</span>
    </div>
    <div class="result-meta">
      <span>${esc(r.source)} / ${esc(r.source_id)}</span>
      ${date?`<span>${date}</span>`:''}
    </div>
    <div class="result-snippet">${esc(r.snippet)}</div>
    <div class="result-body" id="body-${i}" data-doc='${JSON.stringify({body:r.body,chunks:r.chunks}).replace(/'/g,"&#39;")}'></div>
  </div>`;
}

function esc(s) { const d=document.createElement('div'); d.textContent=s; return d.innerHTML; }

// ── Init ──
async function init() {
  try {
    const resp = await fetch('data.json');
    DATA = await resp.json();
    bm25 = buildBM25(DATA.chunks);
    document.getElementById('statusText').textContent = `${DATA.documents.length} docs · ${DATA.chunks.length} chunks`;
  } catch(e) {
    document.getElementById('statusText').textContent = 'error';
    console.error('Failed to load data:', e);
  }
}

document.getElementById('searchInput').addEventListener('keydown', e => { if(e.key==='Enter') doSearch(); });
init();

</script>
</body>
</html>
